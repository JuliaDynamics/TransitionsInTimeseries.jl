var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Main-analysis-functions","page":"API","title":"Main analysis functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"IndicatorsChangesConfig\nSlidingWindowConfig\nSegmentedWindowConfig\nestimate_indicator_changes\nIndicatorsChangesResults\nSlidingWindowResults\nSegmentedWindowResults","category":"page"},{"location":"api/#TransitionsInTimeseries.IndicatorsChangesConfig","page":"API","title":"TransitionsInTimeseries.IndicatorsChangesConfig","text":"IndicatorsChangesConfig\n\nSupertype used to define how indicators and their changes are estimated in estimate_indicator_changes. Valid subtypes are:\n\nSlidingWindowConfig.\nSegmentedWindowConfig.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.SlidingWindowConfig","page":"API","title":"TransitionsInTimeseries.SlidingWindowConfig","text":"SlidingWindowConfig <: IndicatorsChangesConfig\nSlidingWindowConfig(indicators, change_metrics; kwargs...)\n\nA configuration that can be given to estimate_indicator_changes. It estimates transitions by a sliding window approach:\n\nEstimate the timeseries of an indicator by sliding a window over the input timeseries.\nEstimate changes of an indicator by sliding a window of the change metric over the indicator timeseries.\n\nindicators is a tuple of indicators (or a single indicator). change_metrics is also a tuple or a single function. If a single function, the same change metric is used for all provided indicators. This way the analysis can be efficiently repeated for many indicators and/or change metrics.\n\nBoth indicators and change metrics are generic Julia functions that input an x::AbstractVector and output an s::Real. Any function may be given and see making custom indicators/change metrics in the documentation for more information on possible optimizations.\n\nThe results output corresponding to SlidingWindowConfig is SlidingWindowResults.\n\nKeyword arguments\n\nwidth_ind::Int=100, stride_ind::Int=1: width and stride given to WindowViewer to compute the indicator from the input timeseries.\nwidth_cha::Int=50, stride_cha::Int=1: width and stride given to WindowViewer to compute the change metric timeseries from the indicator timeseries.\nwhichtime = midpoint: The time vector corresponding to the indicators / change metric timeseries is obtained from t in estimate_indicator_changes using the keyword whichtime. Options include:\nlast: use the last timepoint of each window\nmidpoint: use the mid timepoint of each time window\nfirst: use first timepoint of each window\nIn fact, the indicators time vector is computed simply via\nt_indicator = windowmap(whichtime, t; width_ind, stride_ind)\nt_change = windowmap(whichtime, t_indicator; width_cha, stride_cha)\nso any other function of the time window may be given to extract the time point itself, such as mean or median.\nT = Float64: Element type of input timeseries to initialize some computations.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.SegmentedWindowConfig","page":"API","title":"TransitionsInTimeseries.SegmentedWindowConfig","text":"SegmentedWindowConfig <: IndicatorsChangeConfig\nSegmentedWindowConfig(indicators, change_metrics, tseg_start, tseg_end; kwargs...)\n\nA configuration that can be given to estimate_indicator_changes. It estimates transitions by estimating indicators and changes in user-defined window segments as follows:\n\nFor each segment specified, estimate the corresponding indicator timeseries by sliding a window over the input timeseries (within the window segment).\nFor each segment of the indicator timeseries, estimate a scalar change metric by applying the change metric over the full segment of the indicator timeseries.d\n\ntseg_start, tseg_end are the starts and ends of the window segments (the window segments may overlap, that's okay). indicators, change_metrics are identical as in SlidingWindowConfig.\n\nThe results output corresponding to SlidingWindowConfig is SegmentedWindowResults.\n\nKeyword arguments\n\nwidth_ind::Int=100, stride_ind::Int=1, whichtime = midpoint, T = Float64: keywords identical as in SlidingWindowConfig.\nmin_width_cha::Int=typemax(Int): minimal width required to perform the change metric estimation. If a segment is not sufficiently long, the change metric is NaN.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.estimate_indicator_changes","page":"API","title":"TransitionsInTimeseries.estimate_indicator_changes","text":"estimate_indicator_changes(config::IndicatorsChangesConfig, x [,t]) → result\n\nEstimate possible transitions for input timeseries x using the approach specified in the configuration type config, see IndicatorsChangesConfig for possibilities. t is the time vector corresponding to x, which defaults to eachindex(x).\n\nReturn the output as subtype of IndicatorsChangesResults. The particular form of the output depends on the config and is described in its docstring. Regardless of type, result can always be given to significant_transitions to deduce which possible transitions are statistically significant using a variety of significance tests.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.IndicatorsChangesResults","page":"API","title":"TransitionsInTimeseries.IndicatorsChangesResults","text":"IndicatorsChangesResults\n\nSupertype used to gather results of estimate_indicator_changes. The concrete subtype instances are described in the docstrings of configuration types.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.SlidingWindowResults","page":"API","title":"TransitionsInTimeseries.SlidingWindowResults","text":"SlidingWindowResults <: IndicatorsChangesResults\n\nA struct containing the output of estimate_indicator_changes used with SlidingWindowConfig. It can be used for further analysis, visualization, or given to significant_transitions.\n\nIt has the following fields that the user may access\n\nx: the input timeseries.\nt: the time vector of the input timeseries.\nx_indicator, the indicator timeseries (matrix with each column one indicator).\nt_indicator, the time vector of the indicator timeseries.\nx_change, the change metric timeseries (matrix with each column one change metric).\nt_change, the time vector of the change metric timeseries.\nconfig::SlidingWindowConfig, what was used for the analysis.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.SegmentedWindowResults","page":"API","title":"TransitionsInTimeseries.SegmentedWindowResults","text":"SegmentedWindowResults <: IndicatorsChangesResults\n\nA struct containing the output of estimate_indicator_changes used with SegmentedWindowConfig. It can be used for further analysis, visualization, or given to significant_transitions.\n\nIt has the following fields that the user may access\n\nx: the input timeseries.\nt: the time vector of the input timeseries.\nx_indicator::Vector{Matrix}, with x_indicator[k] the indicator timeseries (matrix  with each column one indicator) of the k-th segment.\nt_indicator::Vector{Vector}, with t_indicator[k] the time vector of the indicator timeseries for the k-th segment.\nx_change::Matrix, the change metric values with x[k, i] the change metric of the i-th indicator for the k-th segment.\nt_change, the time vector of the change metric.\nconfig::SegmentedWindowConfig, what was used for the analysis.\n\n\n\n\n\n","category":"type"},{"location":"api/#Significance-testing","page":"API","title":"Significance testing","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"significant_transitions\nTransitionsSignificance\nSurrogatesSignificance\nQuantileSignificance","category":"page"},{"location":"api/#TransitionsInTimeseries.significant_transitions","page":"API","title":"TransitionsInTimeseries.significant_transitions","text":"significant_transitions(res::IndicatorsChangesResults, signif::TransitionsSignificance)\n\nEstimate significant transtions in res using the method described by signif. Return flags, a Boolean matrix with identical size as res.x_change. It contains trues wherever a change metric of res is deemed significant.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.TransitionsSignificance","page":"API","title":"TransitionsInTimeseries.TransitionsSignificance","text":"TransitionsSignificance\n\nSupertype used to test for significance in significant_transitions. Valid subtypes are:\n\nSurrogatesSignificance.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.SurrogatesSignificance","page":"API","title":"TransitionsInTimeseries.SurrogatesSignificance","text":"SurrogatesSignificance <: TransitionsSignificance\nSurrogatesSignificance(; surrogate = RandomFourier(), n = 10_000, tail = :both, rng)\n\nA configuration struct for significance testing significant_transitions using timeseries surrogates.\n\nKeyword arguments\n\nsurromethod = RandomFourier(): method to generate surrogates\nn = 1000: how many surrogates to generate\nrng = Random.default_rng(): random number generator for the surrogates\np = 0.05: threshold for significance of the p-value\ntail = :both: tail type used, see below\n\nDescription\n\nWhen used with IndicatorsChangesResults, significance is estimated as follows: n surrogates from the input timeseries are generated using surromethod, which is any Surrogate subtype provided by TimeseriesSurrogates.jl. For each surrogate, the indicator and then change metric timeseries is extracted. The values of the surrogate change metrics form a distribution of values (one at each time point). The value of the original change metric is compared to that of the surrogate distribution and a p-value is extracted according to the specified tail. The p-value is compared with p to claim significance. After using SurrogatesSignificance, you may access the full p-values before thresholding in the field .pvalues (to e.g., threshold with different p).\n\nThe p-value is simply the proportion of surrogate change metric values that exceed (for tail = :right) or subseed (tail = :left) the original change metric at each given time point. Use tail = :left if the surrogate data are expected to have higher change metric, discriminatory statistic values. This is the case for statistics that quantify entropy. For statistics that quantify autocorrelation, use tail = :right instead. For anything else, use the default tail = :both. An iterable of tail values can also be given, in which case a specific tail is used for each change metric in IndicatorsChangesResults.\n\nNote that the raw p-values can be accessed in the field .pvalues, after calling the significant_transitions function with SurrogatesSignificance, in case you wish to obtain a different threshold of the p-values.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.QuantileSignificance","page":"API","title":"TransitionsInTimeseries.QuantileSignificance","text":"QuantileSignificance(; p = 0.95, tail = :both) <: TransitionsSignificance\n\nA configuration struct for significance testing significant_transitions. When used with IndicatorsChangesResults, significance is estimated by comparing the value of each change metric with its p-quantile. Values that exceed the p-quantile (if tail = :right) or subseed the 1-p-quantile (if tail = :left) are deemed significant. If tail = :both then either condition is checked.\n\nQuantileSignficance guarantees that some values will be significant by the very definition of what a quantile is. See also SigmaSignificance that is similar but does not have this guarantee.\n\n\n\n\n\n","category":"type"},{"location":"api/#indicators","page":"API","title":"Indicators","text":"","category":"section"},{"location":"api/#Value-distribution","page":"API","title":"Value distribution","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Statistics.mean(::Any)\nStatsBase.skewness\nStatsBase.kurtosis","category":"page"},{"location":"api/#Statistics.mean-Tuple{Any}","page":"API","title":"Statistics.mean","text":"mean(itr)\n\nCompute the mean of all elements in a collection.\n\nnote: Note\nIf itr contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the mean of non-missing values.\n\nExamples\n\njulia> using Statistics\n\njulia> mean(1:20)\n10.5\n\njulia> mean([1, missing, 3])\nmissing\n\njulia> mean(skipmissing([1, missing, 3]))\n2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsBase.skewness","page":"API","title":"StatsBase.skewness","text":"skewness(v, [wv::AbstractWeights], m=mean(v))\n\nCompute the standardized skewness of a real-valued array v, optionally specifying a weighting vector wv and a center m.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsBase.kurtosis","page":"API","title":"StatsBase.kurtosis","text":"kurtosis(v, [wv::AbstractWeights], m=mean(v))\n\nCompute the excess kurtosis of a real-valued array v, optionally specifying a weighting vector wv and a center m.\n\n\n\n\n\n","category":"function"},{"location":"api/#Critical-Slowing-Down","page":"API","title":"Critical Slowing Down","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Statistics.var(::AbstractArray)\nar1_whitenoise","category":"page"},{"location":"api/#Statistics.var-Tuple{AbstractArray}","page":"API","title":"Statistics.var","text":"var(itr; corrected::Bool=true, mean=nothing[, dims])\n\nCompute the sample variance of collection itr.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of itr is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating sum((itr .- mean(itr)).^2) / (length(itr) - 1). If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n is the number of elements in itr.\n\nIf itr is an AbstractArray, dims can be provided to compute the variance over dimensions.\n\nA pre-computed mean may be provided. When dims is specified, mean must be an array with the same shape as mean(itr, dims=dims) (additional trailing singleton dimensions are allowed).\n\nnote: Note\nIf array contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the variance of non-missing values.\n\n\n\n\n\n","category":"method"},{"location":"api/#TransitionsInTimeseries.ar1_whitenoise","page":"API","title":"TransitionsInTimeseries.ar1_whitenoise","text":"ar1_whitenoise(x::AbstractVector)\n\nReturn the AR1 regression coefficient of a time series x by computing the analytic solution of the least-square parameter estimation under white-noise assumption for the data-generating process:\n\ntheta = sum_i=2^n x_i  x_i-1  sum_i=2^n x_i-1^2\n\n\n\n\n\n","category":"function"},{"location":"api/#Spectrum","page":"API","title":"Spectrum","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LowfreqPowerSpectrum","category":"page"},{"location":"api/#TransitionsInTimeseries.LowfreqPowerSpectrum","page":"API","title":"TransitionsInTimeseries.LowfreqPowerSpectrum","text":"LowfreqPowerSpectrum(; q_lofreq = 0.1)\n\nReturn a PrecomputableFunction containing all the necessary fields to generate a PrecomputedLowfreqPowerSpectrum. The latter can be initialized by precompute:\n\nlfps = precompute( LowfreqPowerSpectrum() )\n\nKeyword arguments:\n\nq_lofreq: a number between 0 and 1 that characterises which portion of the\n\nfrequency spectrum is considered to be low. For instance, q_lofreq = 0.1 implies  that the lowest 10% of frequencies are considered to be the low ones.\n\n\n\n\n\n","category":"type"},{"location":"api/#Nonlinear-dynamics","page":"API","title":"Nonlinear dynamics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Indicators that come from nonlinear timeseries analysis typically quantify some entropy-like or complexity measure from the timeseries. Thousands (literally) such measures are provided out of the box by the ComplexityMeasures.jl package. Given that any of these may be used as an indicator or change metric, we made the decision to not copy-paste any measure here, as it is easy for the user to use any of them.","category":"page"},{"location":"api/","page":"API","title":"API","text":"For example, using the permutation entropy as an indicator is as simple as doing","category":"page"},{"location":"api/","page":"API","title":"API","text":"using ComplexityMeasures\nest = OrdinalPatterns(; m = 3) # order 3\n# create a function that given timeseries returns permutation entropy\nindicator = x -> entropy_normalized(est, x)","category":"page"},{"location":"api/","page":"API","title":"API","text":"and giving the created indicator to e.g., SlidingWindowConfig.","category":"page"},{"location":"api/#change_metrics","page":"API","title":"Change metrics","text":"","category":"section"},{"location":"api/#Slope","page":"API","title":"Slope","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"kendalltau\nspearman\nRidgeRegressionSlope","category":"page"},{"location":"api/#TransitionsInTimeseries.kendalltau","page":"API","title":"TransitionsInTimeseries.kendalltau","text":"kendalltau(x::AbstractVector)\n\nCompute the kendall-τ correlation coefficient of the time series x. kendalltau can be used as a change metric focused on trend.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.spearman","page":"API","title":"TransitionsInTimeseries.spearman","text":"spearman(x::AbstractVector)\n\nCompute the spearman correlation coefficient of the time series x. spearman can be used as a change metric focused on trend.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.RidgeRegressionSlope","page":"API","title":"TransitionsInTimeseries.RidgeRegressionSlope","text":"RidgeRegressionSlope(; lambda = 0.0) → rr\n\nReturn a PrecomputableFunction containing all the necessary fields to generate a PrecomputedRidgeRegressionSlope. rr can be used as a change metric focused on trend.\n\nlambda is a regularization constant, usually between 0 and 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#Value-distribution-differences","page":"API","title":"Value distribution differences","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"difference_of_means","category":"page"},{"location":"api/#TransitionsInTimeseries.difference_of_means","page":"API","title":"TransitionsInTimeseries.difference_of_means","text":"difference_of_means(x::AbstractArray)\n\nReturn the absolute difference of the means of the first and second halfs of x. difference_of_means can be used as a change metric focused on value differences. Creating similar statistical differences using other moments instead of mean is trivial. In fact, the source of difference_of_means is just:\n\n# assumes 1-based indexing\nn = length(x)\nx1 = view(x, 1:n÷2)\nx2 = view(x, (n÷2 + 1):n)\nreturn abs(mean(x1) - mean(x2))\n\ndifference_of_means can also sensibly be used for windows of size 2, in which case the change metric timeseries is the same as the abs.(diff(...)) of the indicator timeseries.\n\n\n\n\n\n","category":"function"},{"location":"api/#own_indicator","page":"API","title":"Make your own indicator/metric!","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The only difference between what is an \"indicator\" and what is a \"change metric\" is purely conceptual. As far as the code base of TransitionsInTimeseries.jl is concerned, they are both functions f: x::AbstractVector{Real} -> f(x)::Real. As a user you may give any such function for an indicator or change metric.","category":"page"},{"location":"api/","page":"API","title":"API","text":"There are situations where you may optimize such a function based on knowledge of input x type and length, in which case you may use PrecomputableFunction:","category":"page"},{"location":"api/","page":"API","title":"API","text":"PrecomputableFunction\nprecompute","category":"page"},{"location":"api/#TransitionsInTimeseries.PrecomputableFunction","page":"API","title":"TransitionsInTimeseries.PrecomputableFunction","text":"PrecomputableFunction\n\nSupertype of structs containing the necessary field to precompute a ::Function by:\n\nprecompute(f::PrecomputableFunction, t)\n\n\n\n\n\n","category":"type"},{"location":"api/#Surrogates","page":"API","title":"Surrogates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"For the surrogate generation, you can use any subtype of Surrogate defined in Timeseriessurrogates.jl.","category":"page"},{"location":"api/#Sliding-windows","page":"API","title":"Sliding windows","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"WindowViewer\nwindowmap\nwindowmap!","category":"page"},{"location":"api/#TransitionsInTimeseries.WindowViewer","page":"API","title":"TransitionsInTimeseries.WindowViewer","text":"WindowViewer(x; width, stride)\n\nInitialize an iterator that generates views over the given timeseries x based on a window with a given width, incrementing the window views with the given stride. You can use this directly with map, such as map(std, WindowViewer(x, ...)) would give you the moving-window-timeseries of the std of x.\n\nIf not given, the keywords width, stride are taken as default_window_width(x) and 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.windowmap","page":"API","title":"TransitionsInTimeseries.windowmap","text":"windowmap(f::Function, x::AbstractVector; kwargs...) → mapped_f\n\nA shortcut for first generating a wv = WindowViewer(x; kwargs...) and then applying mapped_f = map(f, wv). If x is accompanied by a time vector t, you probably also want to call this function with t instead of x and with one of mean, midpoint, midvalue as f to obtain a time vector for the mapped_f output.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.windowmap!","page":"API","title":"TransitionsInTimeseries.windowmap!","text":"windowmap!(f::Function, out, x::AbstractVector; kwargs...)\n\nSame as windowmap, but writes the output in-place in out.\n\n\n\n\n\n","category":"function"},{"location":"api/#Load-data","page":"API","title":"Load data","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"load_linear_vs_doublewell()","category":"page"},{"location":"api/#TransitionsInTimeseries.load_linear_vs_doublewell-Tuple{}","page":"API","title":"TransitionsInTimeseries.load_linear_vs_doublewell","text":"load_linear_vs_doublewell()\n\nLoad prototypical data from a linear and a double-well model to test some indicators.\n\n\n\n\n\n","category":"method"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"EditURL = \"do-events.jl\"","category":"page"},{"location":"examples/do-events/#Dansgaard-Oescher-events-and-Critical-Slowing-Down","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"","category":"section"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"The delta^18O timeseries of the North Greenland Ice Core Project (NGRIP) are, to this date, the best proxy record for the Dansgaard-Oeschger events (DO-events). DO-events are sudden warming episodes of the North Atlantic, reaching 10 degrees of regional warming within 100 years. They happened quasi-periodically over the last glacial cycle due to transitions between strong and weak states of the Atlantic Meridional Overturning Circulation and might be therefore be the most prominent examples of abrupt transitions in the field of climate science. We here propose to hindcast these events by applying the theory of Critical Slowing Down (CSD) on the NGRIP data, which can be found here in its raw format. This analysis has already been done in (Boers, 2018) and we here try to reproduce Figure 2.d-f.","category":"page"},{"location":"examples/do-events/#Preprocessing-NGRIP","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Preprocessing NGRIP","text":"","category":"section"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"Data pre-processing is not part of TransitionsInTimeseries.jl, but a step the user has to do before using the package. To present an example with a complete scientific workflow, we will showcase typical data pre-processing here, that consist of the following steps:","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"Load the data, reverse and offset it to have time vector = time before 2000 AD.\nFilter non-unique points in time and sort the data.\nRegrid the data from uneven to even sampling.","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"The time and delta^18O vectors resulting from the i-th preprocessing step are respectively called t_i and x_i. The final step consists in obtaining a residual r, i.e. the fluctuations of the system around the attractor, which, within the CSD theory, is assumed to be tracked. Over this example, it will appear that the convenience of TransitionsInTimeseries.jl leads the bulk of the code to be written for plotting and preprocessing.","category":"page"},{"location":"examples/do-events/#Step-1:","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Step 1:","text":"","category":"section"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"using DelimitedFiles, Downloads\n\nfunction load_ngrip()\n    tmp = Base.download(\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/\"*\n        \"master/timeseries/NGRIP.csv\")\n    data, labels = readdlm(tmp, header = true)\n    return reverse(data[:, 1]) .- 2000, reverse(data[:, 2]) # (time, delta-18-0) vectors\nend\n\nt1, x1 = load_ngrip()","category":"page"},{"location":"examples/do-events/#Step-2","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Step 2","text":"","category":"section"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"uniqueidx(v) = unique(i -> v[i], eachindex(v))\nfunction keep_unique(t, x)\n    unique_idx = uniqueidx(t)\n    return t[unique_idx], x[unique_idx]\nend\n\nfunction sort_timeseries!(t, x)\n    p = sortperm(t)\n    permute!(t, p)\n    permute!(x, p)\n    return nothing\nend\n\nt2, x2 = keep_unique(t1, x1)\nsort_timeseries!(t2, x2)","category":"page"},{"location":"examples/do-events/#Step-3","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Step 3","text":"","category":"section"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"using BSplineKit\n\nfunction regrid2evensampling(t, x, dt)\n    itp = BSplineKit.interpolate(t, x, BSplineOrder(4))\n    tspan = (ceil(minimum(t)), floor(maximum(t)))\n    t_even = collect(tspan[1]:dt:tspan[2])\n    x_even = itp.(t_even)\n    return t_even, x_even\nend\n\ndt = 5.0        # dt = 5 yr as in (Boers 2018)\nt3, x3 = regrid2evensampling(t2, x2, dt)","category":"page"},{"location":"examples/do-events/#Step-4","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Step 4","text":"","category":"section"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"For the final step we drop the indices:","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"using DSP\n\nfunction chebyshev_filter(t, x, fcutoff)\n    ii = 10             # Chebyshev filtering requires to prune first points of timeseries.\n    responsetype = Highpass(fcutoff, fs = 1/dt)\n    designmethod = Chebyshev1(8, 0.05)\n    r = filt(digitalfilter(responsetype, designmethod), x)\n    xtrend = x - r\n    return t[ii:end], x[ii:end], xtrend[ii:end], r[ii:end]\nend\n\nfcutoff = 0.95 * 0.01   # cutoff ≃ 0.01 yr^-1 as in (Boers 2018)\nt, x, xtrend, r = chebyshev_filter(t3, x3, fcutoff)","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"Let's now visualize our data in what will become our main figure. For the segmentation of the DO-events, we rely on the tabulated data from (Rasmussen et al., 2014) (which will soon be available as downloadable):","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"using CairoMakie, Loess\n\nfunction loess_filter(t, x; span = 0.005)\n    loessmodel = loess(t, x, span = span)\n    xtrend = Loess.predict(loessmodel, t)\n    r = x - xtrend\n    return t, x, xtrend, r\nend\n\nfunction kyr_xticks(tticks_yr)\n    tticks_kyr = [\"$t\" for t in Int.(tticks_yr ./ 1e3)]\n    return (tticks_yr, tticks_kyr)\nend\n\nfunction plot_do(traw, xraw, tfilt, xfilt, t, r, t_transitions, xlims, xticks)\n    fig = Figure(resolution = (1600, 1200), fontsize = 24)\n\n    # Original timeseries with transition marked by vertical lines\n    ax1 = Axis(fig[1, 1], xlabel = L\"Time (kyr) $\\,$\", ylabel = L\"$\\delta^{18}$O (permil)\",\n        xaxisposition = :top, xticks = xticks)\n    lines!(ax1, traw, xraw, color = (:gray70, 0.5))\n    lines!(ax1, tfilt, xfilt, color = :gray10, linewidth = 3)\n    vlines!(ax1, t_transitions, color = Cycled(1), linewidth = 3)\n\n    # Residual timeseries\n    ax2 = Axis(fig[2, 1], ylabel = L\"Residual $\\,$\", xticks = xticks,\n        xticksvisible = false, xticklabelsvisible = false)\n    lines!(ax2, t, r, color = :gray50, linewidth = 1)\n\n    # Axes for variance and AC1 timeseries\n    ax3 = Axis(fig[3, 1], ylabel = L\"Variance $\\,$\", xticks = xticks,\n        xticksvisible = false, xticklabelsvisible = false)\n    ax4 = Axis(fig[4, 1], xlabel = L\"Time (kyr) $\\,$\", ylabel = L\"Lag-1 autocor. $\\,$\",\n        xticks = xticks)\n\n    axs = [ax1, ax2, ax3, ax4]\n    [xlims!(ax, xlims) for ax in axs]\n    ylims!(axs[1], (-48, -34))\n    rowgap!(fig.layout, 10)\n    return fig, axs\nend\n\nxlims = (-60e3, -10e3)\nxticks = kyr_xticks(-60e3:5e3:5e3)\nt_rasmussen = -[-60000, 59440, 58280, 55800, 54220, 49280, 46860, 43340, 41460, 40160,\n                38220, 35480, 33740, 32500, 28900, 27780, 23340, 14692, 11703]\ntloess, _, xloess, rloess = loess_filter(t3, x3)    # loess-filtered signal for visualization\nfig, axs = plot_do(t3, x3, tloess, xloess, t, r, t_rasmussen, xlims, xticks)\nfig","category":"page"},{"location":"examples/do-events/#Hindcast-on-NGRIP-data","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Hindcast on NGRIP data","text":"","category":"section"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"As one can see... there is not much to see so far. Residuals are impossible to simply eye-ball and we therefore use TransitionsInTimeseries.jl to study the evolution, measured by the ridge-regression slope of the residual's variance and lag-1 autocorrelation (AC1) over time. In many examples of the literature, including (Boers, 2018), the CSD analysis is performed over segments (sometimes only one) of the timeseries, such that a significance value is obtained for each segment. By using SegmentedWindowConfig, dealing with segments can be easily done in TransitionsInTimeseries.jl and is demonstrated here:","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"using TransitionsInTimeseries, StatsBase\nusing Random: Xoshiro\n\nac1(x) = sum(autocor(x, [1]))   # AC1 from StatsBase\nindicators = (var, ac1)\nchange_metrics = RidgeRegressionSlope()\ntseg_start = t_rasmussen[1:end-1] .+ 200\ntseg_end = t_rasmussen[2:end] .- 200\nconfig = SegmentedWindowConfig(indicators, change_metrics,\n    tseg_start, tseg_end; whichtime = last, width_ind = Int(200÷dt),\n    min_width_cha = 100)        # require >=100 data points to estimate change metric\nresults = estimate_indicator_changes(config, r, t)\nsignif = SurrogatesSignificance(n = 10_000, tail = :right, rng = Xoshiro(1995))\nflags = significant_transitions(results, signif)","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"That's it! We can now visulaise our results with a generic function that we will re-use later:","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"function plot_segment_analysis!(axs, results, signif)\n    (; t_indicator, x_indicator) = results\n    for k in eachindex(t_indicator)             # loop over the segments\n        for i in axes(signif.pvalues, 2)        # loop over the indicators\n            if !isinf(signif.pvalues[k, i])     # plot if segment long enough\n                # Plot indicator timeseries and its linear regression\n                ti, xi = t_indicator[k], x_indicator[k][:, i]\n                lines!(axs[i+2], ti, xi, color = Cycled(1))\n                m, p = ridgematrix(ti, 0.0) * xi\n                if signif.pvalues[k, i] < 0.05\n                    lines!(axs[i+2], ti, m .* ti .+ p, color = :gray5, linewidth = 3)\n                else\n                    lines!(axs[i+2], ti, m .* ti .+ p, color = :gray60, linewidth = 3)\n                end\n            end\n        end\n    end\nend\nplot_segment_analysis!(axs, results, signif)\nfig","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"In (Boers, 2018), 13/16 and 7/16 true positives are respectively found for the variance and AC1, with 16 referring to the total number of transitions. The timeseries actually includes 18 transition but, in (Boers, 2018), some segments are considered too small to be analysed. In contrast, we here respectively find 9/16 true positives for the variance and 3/16 for AC1. We can track down the discrepancies to be in the surrogate testing, since the indicator timeseries computed here are almost exactly similar to those of (Boers, 2018). This mismatch points out that packages like TransitionsInTimeseries.jl are wishful for research to be reproducible, especially since CSD is gaining attention - not only within the scientific community but also in popular media.","category":"page"},{"location":"examples/do-events/#CSD:-only-a-necessary-condition,-only-in-some-cases","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"CSD: only a necessary condition, only in some cases","text":"","category":"section"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"For codimension-1 systems, approaching a fold, Hopf or transcritical bifurcation implies a widening of the potential U, which defines the deterministic term f = -U of the SDE's right-hand-side. In the presence of noise, this leads to CSD, which is therefore a necessary condition for crossing one of these bifurcations - although it is not always assessable by analysing the timeseries due to practical limitations (e.g. sparse data subject to large measurement noise). It is nonetheless not given that DO-events, as many other real-life applications, can be seen as a codimension-1 fold, Hopf or transcritical bifurcations. Besides this, we emphasise that CSD is not a sufficient condition for assessing a transition being ahead in near future, since a resilience loss can happen without actually crossing any bifurcation. This can be illustrated on the present example by performing the same analysis only until few hundred years before the transition:","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"tseg_end = t_rasmussen[2:end] .- 700    # stop analysis 500 years earlier than before\nconfig = SegmentedWindowConfig(indicators, change_metrics,\n    tseg_start, tseg_end, whichtime = last, width_ind = Int(200÷dt),\n    min_width_cha = 100)\nresults = estimate_indicator_changes(config, r, t)\nsignif = SurrogatesSignificance(n = 10_000, tail = :right, rng = Xoshiro(1995))\nflags = significant_transitions(results, signif)\nfig, axs = plot_do(t3, x3, tloess, xloess, t, r, t_rasmussen, xlims, xticks)\nplot_segment_analysis!(axs, results, signif)\nfig","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"For the variance and AC1, we here respectively find 6 and 3 positives, although the transitions are still far ahead. This shows that what CSD captures is a potential widening induced by a shift of the forcing parameter rather than the actual transition. We therefore believe, as already suggested in some studies, that \"resilience-loss indicators\" is a more accurate name than \"early-warning signals\" when using CSD.","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"We draw attention upon the fact that the delta^18O timeseries is noisy and sparsely re-sampled. Furthermore, interpolating over time introduces a potential bias in the statistics, even if performed on a coarse grid. The NGRIP data therefore represents an example that should be handled with care - as many others where CSD analysis has been applied on transitions in the field of geoscience. To contrast with this, we propose to perform the same analysis on synthethic DO data, obtained from an Earth Model of Intermediate Complexity (EMIC).","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"warning: Degrees of freedom\nThese sources of error come along the usual problem of arbitrarily choosing (1) a filtering method, (2) windowing parameters and (3) appropriate metrics (for instance when the forcing noise is suspected to be correlated). This leads to a large number of degrees of freedom (DoF). Although sensible guesses are possible here, checking that results are robust w.r.t. the DoF should be a standard practice.","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"info: Future improvement\nSupporting the computations for uneven timeseries is a planned improvement of TransitionsInTimeseries.jl. This will avoid the need of regridding data on coarse grids and will prevent from introducing any bias.","category":"page"},{"location":"examples/do-events/#Hindcasting-simulated-DO-events","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Hindcasting simulated DO-events","text":"","category":"section"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"In CLIMBER-X, the EMIC described in (Willeit et al., 2022), DO-like events can be triggered by forcing the North Atlantic with a (white noise) freshwater input. Simulated DO-like events present the big advantage of being evenly sampled in time and free of measurement noise. We run this analysis over two exemplary simulation outputs:","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"t_transitions = [[1, 1850, 2970, 3970, 5070, 5810, 7050, 8050],\n                 [1, 3500, 4370, 5790, 7200, 8140]]\nt_lb = [[300, 500, 300, 600, 300, 500, 500], [1800, 500, 1000, 900, 500]]\ntseg_start = [t_transitions[1][1:end-1] + t_lb[1], t_transitions[2][1:end-1] + t_lb[2]]\ntseg_end = [t_transitions[1][2:end] .- 50, t_transitions[2][2:end] .- 50]\n\nfigvec = Figure[]\n\nfor j in 1:2\n    # Download the data and perform loess filtering on it\n    tmp = Base.download(\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/\" *\n        \"master/timeseries/climberx-do$(j)-omaxa.csv\")\n    data = readdlm(tmp)\n    tcx, xcx = data[1, 1000:end], data[2, 1000:end]\n    t, x, xtrend, r = loess_filter(tcx, xcx, span = 0.02)\n\n    # Initialize figure\n    xlims = (0, last(tcx))\n    xticks = kyr_xticks(xlims[1]:1e3:xlims[2])\n    fig, axs = plot_do(tcx, xcx,  t, xtrend, t, r, t_transitions[j], extrema(t), xticks)\n    ylims!(axs[1], (5, 40))\n    axs[1].ylabel = L\"Max. Atlantic overturning (Sv) $\\,$\"\n\n    # Run sliding analysis and update figure with results\n    dt = mean(diff(tcx))\n    config = SegmentedWindowConfig(\n        indicators, change_metrics, tseg_start[j], tseg_end[j],\n        whichtime = last, width_ind = Int(200÷dt), min_width_cha = 100)\n    results = estimate_indicator_changes(config, r, t)\n    signif = SurrogatesSignificance(n = 1_000, tail = :right, rng = Xoshiro(1995))\n    flags = significant_transitions(results, signif)\n\n    plot_segment_analysis!(axs, results, signif)\n    vlines!(axs[1], t_transitions[j], color = Cycled(1), linewidth = 3)\n    push!(figvec, fig)\nend\nfigvec[1]","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"It here appears that not all transitions are preceeded by a significant increase of variance and AC1, even in the case of clean and evenly sampled time series. Let's check another case:","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"figvec[2]","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events and Critical Slowing Down","title":"Dansgaard-Oescher events and Critical Slowing Down","text":"Same here! Although CLIMBER-X does not represent real DO-events, the above-performed analysis might be hinting at the fact that not all DO transitions can be forecasted with CSD. Nonetheless, performing a CSD analysis can inform on the evolution of a system's resilience.","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"EditURL = \"logistic.jl\"","category":"page"},{"location":"examples/logistic/#Permutation-entropy-for-dynamic-regime-changes","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"","category":"section"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"Permutation entropy is used frequently to detect a transition between one dynamic regime to another. It is useful when the mean and std. of the timeseries values are very similar between the two regimes, which would mean that common distribution-based indicators, or common critical-slowing-down based indicators, would fail.","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"This example will also explore different ways to test for significance that are arguably better suitable in such an application than the Tutorial's default of significance via random Fourier surrogates.","category":"page"},{"location":"examples/logistic/#Logistic-map-timeseries","page":"Permutation entropy for dynamic regime changes","title":"Logistic map timeseries","text":"","category":"section"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"A simple example of this is transitions from periodic to weakly chaotic to chaotic motion in the logistic map. First, let's generate a timeseries of the logistic map","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"using DynamicalSystemsBase\nusing CairoMakie\n\n# time-dependent logistic map, so that the `r` parameter increases with time\nr1 = 3.83\nr2 = 3.86\nN = 2000\nrs = range(r1, r2; length = N)\n\nfunction logistic_drifting_rule(u, rs, n)\n    r = rs[n+1] # time is `n`, starting from 0\n    return SVector(r*u[1]*(1 - u[1]))\nend\n\nds = DeterministicIteratedMap(logistic_drifting_rule, [0.5], rs)\nx = trajectory(ds, N-1)[1][:, 1]","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"Plot it, using as time the parameter value (they coincide)","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"fig, ax = lines(rs, x; linewidth = 0.5)\nax.xlabel = \"r (time)\"\nax.ylabel = \"x\"\nfig","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"In this example there is a rather obvious transition to strongly chaotic motion at r ≈ 3.855. However, there is also a subtle transition to weak chaos at r ≈ 3.847. This transition is barely visible in the timeseries, and in fact many of the timeseries statistical properties remain identical.","category":"page"},{"location":"examples/logistic/#Using-a-simpler-change-metric","page":"Permutation entropy for dynamic regime changes","title":"Using a simpler change metric","text":"","category":"section"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"Now, let's compute and various indicators and their changes, focusing on the permutation entropy as an indicator. We use order 4 here, because we know that to detect changes in a period m we would need an order ≥ m+1 permutation entropy.","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"using TransitionsInTimeseries, ComplexityMeasures\n\nfunction permutation_entropy(m)\n    est = SymbolicPermutation(; m) # order 3\n    indicator = x -> entropy_normalized(est, x)\n    return indicator\nend\n\nindicators = (var, ar1_whitenoise, permutation_entropy(4))\nindistrings = (\"var\", \"ar1\", \"pe\")","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"In this example there is no critical slowing down; instead, there is a sharp transition between periodic and chaotic motion. Hence, we shouldn't be using any trend-based change metrics. Instead, we will use the most basic change metric, difference_of_means. With this metric it also makes most sense to use as stride half the window width","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"metric = difference_of_means\n\nwidth_ind = N÷100\nwidth_cha = 20\nstride_cha = 10\n\nconfig = SlidingWindowConfig(indicators, metric;\n    width_ind, width_cha, stride_cha,\n)\n\nresults = estimate_indicator_changes(config, x, rs)","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"Let's now plot the change metrics of the indicators","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"function plot_change_metrics()\n    fig, ax = lines(rs, x; axis = (ylabel = \"input\",), figure = (resolution = (600, 600),))\n    hidexdecorations!(ax; grid = false)\n    # plot all change metrics\n    for (i, c) in enumerate(eachcol(results.x_change))\n        ax, = scatterlines(fig[i+1, 1], results.t_change, c;\n            axis = (ylabel = indistrings[i],), label = \"input\"\n        )\n        if i < 3\n            hidexdecorations!(ax; grid = false)\n        else\n            ax.xlabel = \"r (time)\"\n        end\n    end\n    return fig\nend\n\nfig = plot_change_metrics()","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"We already see the interesting results we expect: the permutation entropy shows a striking change as we go from periodic to weakly chaotic motion at r ≈ 3.847. (Remember: the plotted quantity is how much the indicator changes within a time window. High values mean large changes.)","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"Due to its construction, permutation entropy will have a spike for periodic data at the start of the timeseries, so we can safely ignore the spike at r ≈ 3.83.","category":"page"},{"location":"examples/logistic/#Significance-via-random-Fourier-surrogates","page":"Permutation entropy for dynamic regime changes","title":"Significance via random Fourier surrogates","text":"","category":"section"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"One way to test for significance would be via the standard way as in the Tutorial, utilizing surrogate timeseries and SurrogatesSignificance.","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"Let's do it here for an example, but, we have to be careful. It is crucial that for permutation entropy we use :right as the tail, because it is expected that the surrogates will have higher differences in the permutation entropy timeseries (because, if there is no dynamical change, the permutation entropy will stay the same, while in the surrogates there are always random fluctuations!","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"surromethod = RandomFourier()\n\n# Define a function because we will re-use later\nusing Random: Xoshiro\nfunction overplot_surrogate_significance!(fig, surromethod, color = \"black\")\n\n    signif = SurrogatesSignificance(;\n        n = 2000, tail = [:both, :both, :right], surromethod, rng = Xoshiro(42),\n    )\n    flags = significant_transitions(results, signif)\n\n    # and also plot the flags with same color\n    for (i, indicator) in enumerate(indicators)\n        # To make things visually clear, we will also plot some example surrogate\n        # timeseries for each indicator and change metric pair\n        for _ in 1:10\n            s = TimeseriesSurrogates.surrogate(x, surromethod)\n            p = windowmap(indicator, s; width = width_ind)\n            q = windowmap(metric, p; width = width_cha, stride = stride_cha)\n            lines!(fig[i+1, 1], results.t_change, q;  color = (color, 0.2), linewidth = 1)\n        end\n        # Plot the flags as vertical dashed lines\n        vlines!(fig[i+1, 1], results.t_change[flags[:, i]];\n            color = color, linestyle = :dash, linewidth = 3\n        )\n    end\n    # add a title to the figure with how we estimate significance\n    content(fig[1, 1]).title = \"surrogates: \"*string(nameof(typeof(surromethod)))\nend\n\nsurromethod = RandomFourier()\noverplot_surrogate_significance!(fig, surromethod)\n\nfig","category":"page"},{"location":"examples/logistic/#Different-surrogates","page":"Permutation entropy for dynamic regime changes","title":"Different surrogates","text":"","category":"section"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"Random Fourier surrogates perserve the power spectrum of the timeseries, but the power spectrum is a property integrated over the whole timeseries. It doesn't contain any information highlighting the local dynamics or information that preserves the local changes of dynamical behavior.","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"A surrogate type that does a better job in preserving local sharp changes in the timeseries (and hence provides stricter surrogate-based significance) is for example RelativePartialRandomization.","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"A much better alternative is to use block-shuffled surrogates, which preserve the short term local temporal correlation in the timeseries and hence also preserve local short term sharp changes in the dynamic behavior.","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"surromethod = RelativePartialRandomization(0.25)\nfig = plot_change_metrics()\noverplot_surrogate_significance!(fig, surromethod, \"gray\")\nfig","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"Our results have improved. In the permutation entropy, we see only two transitions detected as significant, which is correct: only two real dynamical transitions exist in the data. In the other two indicators we also see fewer transitions, but as we have already discussed, no results with the other indicators should be taken into meaningful consideration, as these indicators are simply inappropriate for what we are looking for here.","category":"page"},{"location":"examples/logistic/#Simpler-Significance","page":"Permutation entropy for dynamic regime changes","title":"Simpler Significance","text":"","category":"section"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"Arguably, exactly because we are using the difference_of_means as a change metric, we may want to be less strict and more simple with our tests for significance. Instead of using SurrogatesSignificance we may use the simpler and much faster SigmaSignificance, which simply claims significant time points whenever a change metric exceeds some pre-defined factor of its timeseries standard deviation.","category":"page"},{"location":"examples/logistic/","page":"Permutation entropy for dynamic regime changes","title":"Permutation entropy for dynamic regime changes","text":"fig = plot_change_metrics()\nflags = significant_transitions(results, SigmaSignificance(factor = 5.0))\n\n# Plot the flags\nfor (i, indicator) in enumerate(indicators)\n    vlines!(fig[i+1, 1], results.t_change[flags[:, i]];\n        color = Cycled(3), linestyle = :dash, linewidth = 3\n    )\nend\ncontent(fig[1, 1]).title = \"significance from std\"\nfig","category":"page"},{"location":"#TransitionsInTimeseries.jl","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"","category":"section"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"(Image: TransitionsInTimeseries.jl)","category":"page"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"TransitionsInTimeseries","category":"page"},{"location":"#TransitionsInTimeseries","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries","text":"TransitionsInTimeseries.jl\n\n(Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package for estimating transitions (from one dynamic regime or stable state to another) in timeseries and testing the statistical significance of found transitions. It integrates with the entire Julia ecosystem of timeseries analysis, and hence offers thousands of metrics that can indicate transitions right out of the box. It also offers a variety of analysis pipelines for identifying transitions and a variety of statistical pipelines for testing for significance.\n\nIn contrast to other existing software with similar target application, TransitionsInTimeseries.jl defines a generic interface for how to find transitions and how to test for significance. Within this interface, it is easy to expand the software in three orthogonal ways:\n\nAdd new indicators that work with the existing analysis pipelines for finding transitions\nAdd new analysis pipelines for finding transitions\nAdd new ways for testing whether already found transitions are significant\n\nThis package is currently under active development and not yet registered in the Julia general registry. To install it, first go into package-manager mode in the Julia REPL (press ]) and then run\n\nadd https://github.com/JuliaDynamics/TransitionsInTimeseries.jl\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nAlternative names for this package could have been: Early Warning Signals / Resilience Indicators / Regime-Shift Identifiers / Change-Point Detectors, or however else you want to call them!\n\n\n\n\n\n","category":"module"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"info: Star us on GitHub!\nIf you have found this package useful, please consider starring it on GitHub. This gives us an accurate lower bound of the (satisfied) user count.","category":"page"},{"location":"#content","page":"TransitionsInTimeseries.jl","title":"Content","text":"","category":"section"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"Multi-stable systems can display abrupt transitions between two stability regimes. To predict such transitions in real-world systems solely based on data, mathematical tools have been developed in the last decades. Numerous terminologies have been used for them, such as early warning signals, resilience indicators, regime-shift identifiers, change-point detection and transition indicators. TransitionsInTimeseries.jl sticks to the latter terminology and provides an interface that:","category":"page"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"Allows a fast computation of common transition indicators with a couple of lines, as demonstrated in the example section.\nMakes the surrogate analysis to test for significance under the hub.\nCan be easily extended by any user without touching the source code.\nReduces the programming overhead for any researcher willing to benchmark new methods.\nEases the reproducibility thanks to a clear syntax, a simple installation and RNG-seeded surrogate generation.\nIncreases trustworthiness thanks to a large test suite.","category":"page"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"info: Similar projects\nAn R toolbox and a Python library already exist. However, we believe that they are difficult to extend for the user. Furthermore, they do not offer a native performant code, as here allowed by the use of Julia.","category":"page"},{"location":"#approaches","page":"TransitionsInTimeseries.jl","title":"Approaches","text":"","category":"section"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"Over the last decades, research on transition indicators has largely focused on Critical Slowing Down (CSD). CSD is observed when a system approaches a Hopf, a transcritical or a fold bifurcation and consists in a resilience loss of the system. For instance this can be diagnosed by an increase of the variance and the AR1-regression coefficient, as demonstrated in the example section. However, we emphasize that this is one out of many possible approaches for obtaining transition indicators. Recent work has explored new approaches relying on nonlinear dynamics or machine learning. TransitionsInTimeseries.jl is designed to allow these cutting-edge methods and foster the development of new ones.","category":"page"},{"location":"refs/#References","page":"References","title":"References","text":"","category":"section"},{"location":"refs/","page":"References","title":"References","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"tutorial.jl\"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#workflow","page":"Tutorial","title":"Workflow","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Computing transition indicators consists of the following steps:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Doing any preprocessing of raw data first, such as detrending (not part of TransitionsInTimeseries.jl). This yields the input timeseries.\nEstimating the timeseries of an indicator by sliding a window over the input timeseries.\nComputing the changes of the indicator by sliding a window over its timeseries.\nGenerating many surrogates that preserve important statistical properties of the original timeseries.\nPerforming step 2 and 3 for the surrogate timeseries.\nChecking whether the indicator change timeseries of the real timeseries shows a significant feature (trend, jump or anything else) when compared to the surrogate data.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These steps are illustrated one by one in the tutorial below, and then summarized in the convenient API that TransitionsInTimeseries.jl exports.","category":"page"},{"location":"tutorial/#example_stepbystep","page":"Tutorial","title":"Tutorial – Educational","text":"","category":"section"},{"location":"tutorial/#Raw-input-data","page":"Tutorial","title":"Raw input data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let us load data from a bistable nonlinear model subject to noise and to a gradual change of the forcing that leads to a transition. Furthermore, we also load data from a linear model, which is by definition monostable and therefore incapable of transitioning. This is done to control the rate of false positives, a common problem that can emerge when looking for transition indicators. The models are governed by:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dfracmathrmdx_lmathrmdt = - x_l - 1 + f(t) + n(t) \ndfracmathrmdx_nlmathrmdt = - x_nl^3 + x_nl + f(t) + n(t)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"with x_l the state of the linear model, x_nl the state of the bistable model, f the forcing and n the noise. For f=0 they both display an equilibrium point at x=-1. However, the bistable model also displays a further equilibrium point at x=1. Loading (and visualizing with Makie) such prototypical data to test some indicators can be done by simply running:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TransitionsInTimeseries, CairoMakie\n\nt, x_linear, x_nlinear = load_linear_vs_doublewell()\nfig, ax = lines(t, x_linear)\nlines!(ax, t, x_nlinear)\nax.title = \"raw data\"\nfig","category":"page"},{"location":"tutorial/#Preprocessing","page":"Tutorial","title":"Preprocessing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Not part of TransitionsInTimeseries.jl\nAny timeseries preprocessing, such as the de-trending step we do here, is not part of TransitionsInTimeseries.jl and is the responsibility of the researcher.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The nonlinear system clearly displays a transition between two stability regimes. To forecast such transition, we analyze the fluctuations of the timeseries around the attractor, assumed to be tracked. Therefore, a detrending step is needed - here simply obtained by building the difference of the timeseries with lag 1.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"x_l_fluct = diff(x_linear)\nx_nl_fluct = diff(x_nlinear)\ntfluct = t[2:end]\n\nfig, ax = lines(tfluct, x_l_fluct)\nlines!(ax, tfluct, x_nl_fluct .+ 0.05)\nax.title = \"input timeseries\"\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"At this point, x_l_fluct and x_nl_fluct are considered the input timeseries.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Detrending in Julia\nDetrending can be performed in many ways. A wide range of Julia packages exists to perform smoothing such as Loess.jl or DSP.jl. There the detrending step consists of subtracting the smoothed signal from the original one.","category":"page"},{"location":"tutorial/#Indicator-timeseries","page":"Tutorial","title":"Indicator timeseries","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can then compute the values of some \"indicator\" (a Julia function that inputs a timeseries and outputs a number). An indicator should be a quantity that is likely to change if a transition occurs, or is about to occur in the timeseries. We compute indicators by applying a sliding window over the input timeseries, determined by the width and the stride with which it is applied. Here we demonstrate this computation with the AR1-regression coefficient (under white-noise assumption), implemented as ar1_whitenoise:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"indicator = ar1_whitenoise\nindicator_window = (width = 400, stride = 1)\n\n# By mapping `last::Function` over a windowviewer of the time vector,\n# we obtain the last time step of each window.\n# This therefore only uses information from `k-width+1` to `k` at time step `k`.\n# Alternatives: `first::Function`, `midpoint:::Function`.\nt_indicator = windowmap(last, tfluct; indicator_window...)\nindicator_l = windowmap(indicator, x_l_fluct; indicator_window...)\nindicator_nl = windowmap(indicator, x_nl_fluct; indicator_window...)\n\nfig, ax = lines(t_indicator, indicator_l)\nlines!(ax, t_indicator, indicator_nl)\nax.title = \"indicator timeseries\"\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The lines plotted above are the indicator timeseries.","category":"page"},{"location":"tutorial/#Change-metric-timeseries","page":"Tutorial","title":"Change metric timeseries","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"From here, we process the indicator timeseries to quantify changes in it. This step is in essence the same as before: we apply some function over a sliding window of the indicator timeseries. We call this new timeseries the change metric timeseries. In the example here, the change metric we will employ will be the slope (over a sliding window), calculated via means of a RidgeRegressionSlope:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"change_window = (width = 30, stride = 1)\nridgereg = RidgeRegressionSlope(lambda = 0.0)\nprecompridgereg = precompute(ridgereg, t[1:change_window.width])\n\nt_change = windowmap(last, t_indicator; change_window...)\nchange_l = windowmap(precompridgereg, indicator_l; change_window...)\nchange_nl = windowmap(precompridgereg, indicator_nl; change_window...)\n\nfig, ax = lines(t_change, change_l)\nlines!(ax, t_change, change_nl)\nax.title = \"change metric timeseries\"\nfig","category":"page"},{"location":"tutorial/#Timeseries-surrogates","page":"Tutorial","title":"Timeseries surrogates","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected from Critical Slowing Down, an increase of the AR1-regression coefficient can be observed. Although eyeballing the timeseries might already be suggestive, we want a rigorous framework for testing for significance.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In TransitionsIdentifiers.jl we perform significance testing using the method of timeseries surrogates and the TimeseriesSurrogates.jl Julia package. This has the added benefits of reproducibility, automation and flexibility in choosing the surrogate generation method. Note that TimeseriesSurrogates is re-exported by TransitionsInTimeseries, so that you don't have to using both of them.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To illustrate the surrogate, we compare the change metric computed from the bistable timeseries what that computed from a surrogate of the same timeseries.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Generate Fourier random-phase surrogates\nusing Random: Xoshiro\ns = surrogate(x_nl_fluct, RandomFourier(), Xoshiro(123))\n\nfunction gridfig(nrows, ncols)\n    fig = Figure()\n    axs = [Axis(fig[i, j], xticklabelsvisible = i == nrows ? true : false)\n        for j in 1:ncols, i in 1:nrows]\n    rowgap!(fig.layout, 10)\n    return fig, axs\nend\nfig, axs = gridfig(2, 1)\nlines!(axs[1], tfluct, x_nl_fluct, color = Cycled(2))\nlines!(axs[1], tfluct, s .- 0.05, color = Cycled(3))\naxs[1].title = \"real signal vs. surrogate(s)\"\n\n# compute and plot indicator and change metric\nindicator_s = windowmap(indicator, s; indicator_window...)\nchange_s = windowmap(precompridgereg, indicator_s; change_window...)\n\nlines!(axs[2], t_change, change_nl, label = \"nonlin\", color = Cycled(2))\nlines!(axs[2], t_change, change_s, label = \"surrogate\", color = Cycled(3))\naxislegend()\naxs[2].title = \"change metric\"\n\n[xlims!(ax, 0, 50) for ax in axs]\nfig","category":"page"},{"location":"tutorial/#Quantifying-significance","page":"Tutorial","title":"Quantifying significance","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To quantify the significance of the values of the change metric timeseries we perform a standard surrogate test by computing the p-value w.r.t. the change metrics of thousands of surrogates of the input timeseries. A low p-value (typically p<0.05) is commonly considered as significant. To visualize significant trends, we plot the p-value vs. time:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"n_surrogates = 1_000\nfig, axs = gridfig(2, 2)\naxs[1].title = \"linear\"\naxs[2].title = \"nonlinear\"\n\nfor (j, ax, axsig, x) in zip(1:2, axs[1:2], axs[3:4], (x_l_fluct, x_nl_fluct))\n\n    orig_change = j == 1 ? change_l : change_nl\n    sgen = surrogenerator(x, RandomFourier(), Xoshiro(123))\n    pval = zeros(length(change_s))\n\n    # Collect all surrogate change metrics\n    for i in 1:n_surrogates\n        s = sgen()\n        indicator_s = windowmap(indicator, s; indicator_window...)\n        change_s = windowmap(precompridgereg, indicator_s; change_window...)\n        pval += orig_change .< change_s\n    end\n\n    pval ./= n_surrogates\n    lines!(ax, t_change, orig_change)   # ; color = Cycled(j)\n    lines!(axsig, t_change, pval)       # ; color = Cycled(j+2)\nend\n\n[xlims!(ax, 0, 50) for ax in axs]\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected, the data generated by the nonlinear model displays a significant increase of the AR1-regression coefficient before the transition, which is manifested by a low p-value. In contrast, the data generated by the linear model does not show anything similar.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Performing the step-by-step analysis of transition indicators is possible and might be preferred for users wanting high flexibility. However, this results in a substantial amount of code. We therefore provide convenience functions that wrap this analysis, as shown in the next section.","category":"page"},{"location":"tutorial/#example_fastforward","page":"Tutorial","title":"Tutorial – TransitionsInTimeseries.jl","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TransitionsInTimeseries.jl wraps this typical workflow into a simple, extendable, and modular API that researchers can use with little effort. In addition, it allows performing the same analysis for several indicators / change metrics in one go.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The interface is simple, and directly parallelizes the Workflow. It is based on the creation of a TransitionsSurrogatesConfig, which contains a list of indicators, and corresponding metrics, to use for doing the above analysis. It also specifies what kind of surrogates to generate.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The following blocks illustrate how the above extensive example is re-created in TransitionsInTimeseries.jl","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TransitionsInTimeseries, CairoMakie\n\nt, x_linear, x_nlinear = load_linear_vs_doublewell()\n\n# input timeseries and time\ninput = x_nl_fluct = diff(x_nlinear)\nt = t[2:end]\n\nfig, ax = lines(t, input)\nax.title = \"input timeseries\"\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To perform all of the above analysis we follow a 2-step process.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Step 1, we decide what indicators and change metrics to use in SlidingWindowConfig and apply those via a sliding window to the input timeseries using transition_metrics.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# These indicators are suitable for Critical Slowing Down\nindicators = (var, ar1_whitenoise)\n\n# use the ridge regression slope for both indicators\nchange_metrics = RidgeRegressionSlope()\n\n# choices go into a configuration struct\nconfig = SlidingWindowConfig(indicators, change_metrics;\n    width_ind = 400, width_cha = 30, whichtime = last)\n\n# choices are processed\nresults = estimate_indicator_changes(config, input, t)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"From result we can plot the change metric timeseries:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fig, axs = gridfig(3, 1)\nlines!(axs[1], t, input; label = \"input\", color = Cycled(2))\nscatter!(axs[2], results.t_change, results.x_change[:, 1];\n    label = \"var slopes\", color = Cycled(3))\nscatter!(axs[3], results.t_change, results.x_change[:, 2];\n    label = \"ar1 slopes\", color = Cycled(4))\n[xlims!(ax, 0, 50) for ax in axs]\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Step 2 is to estimate significance using SurrogatesConfig and the function estimate_significance!.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"signif = SurrogatesSignificance(n = 1000, tail = :right)\nflags = significant_transitions(results, signif)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now plot the p-values corresponding to each time series of the change metrics. From the flags we can additionally obtain the time points where both indicators show significance, via a simple reduction:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fig, axs = gridfig(2, 1)\nlines!(axs[1], vcat(0.0, t), x_nlinear; label = \"raw\", color = Cycled(1))\nlines!(axs[1], t, input; label = \"input\", color = Cycled(2))\nscatter!(axs[2], results.t_change, signif.pvalues[:, 1];\n    label = \"var p-values\", color = Cycled(3))\nscatter!(axs[2], results.t_change, signif.pvalues[:, 2];\n    label = \"ar1 p-values\", color = Cycled(4))\n\nflagsboth = vec(reduce(&, flags; dims = 2))\nvlines!(axs[1], results.t_change[flagsboth]; label = \"flags\", color = (\"black\", 0.1))\n\n[axislegend(ax) for ax in axs]\n[xlims!(ax, 0, 50) for ax in axs]\nfig","category":"page"}]
}
