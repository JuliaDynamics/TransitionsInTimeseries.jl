var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Main-analysis-functions","page":"API","title":"Main analysis functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"WindowedIndicatorConfig\nestimate_transitions\nWindowedIndicatorResults","category":"page"},{"location":"api/#TransitionsInTimeseries.WindowedIndicatorConfig","page":"API","title":"TransitionsInTimeseries.WindowedIndicatorConfig","text":"WindowedIndicatorConfig(indicators, change_metrics; kwargs...) → config\n\nA configuration struct for TransitionsInTimeseries.jl that collects what indicators and corresponding metrics to use in the transitions_analysis.\n\nindicators is a tuple of indicators (or a single indicator). change_metrics is also a tuple or a single function. If a single function, the same change metric is used for all provided indicators. This way the analysis can be efficiently repeated for many indicators and/or change metrics.\n\nBoth indicators and change metrics are generic Julia functions that input an x::AbstractVector and output an s::Real. Any appropriate function may be given and see making custom indicators/change metrics in the documentation for more information.\n\nKeyword arguments\n\nwidth_ind::Int=100, stride_ind::Int=1: width and stride given to WindowViewer to compute the indicator from the input timeseries.\nwidth_cha::Int=50, stride_cha::Int=1: width and stride given to WindowViewer to compute the change metric timeseries from the indicator timeseries.\nwhichtime = midpoint: The time vector corresponding to the indicators / change metric timeseries is obtained from t in transitions_analysis using the keyword whichtime. Options include:\nlast: use the last timepoint of each window\nmidpoint: use the mid timepoint of each time window\nfirst: use first timepoint of each window\nIn fact, the indicators time vector is computed simply via\nt_indicator = windowmap(whichtime, t; width_ind, stride_ind)\nt_change = windowmap(whichtime, t_indicator; width_cha, stride_cha)\nso any other function of the time window may be given to extract the time point itself, such as mean or median.\nT = Float64: Element type of input timeseries to initialize some computations.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.estimate_transitions","page":"API","title":"TransitionsInTimeseries.estimate_transitions","text":"estimate_transitions(config::WindowedIndicatorConfig, x [,t]) → output\n\nEstimate possible transitions for input timeseries x using a sliding window approach as described by config:\n\nEstimate the timeseries of an indicator by sliding a window over the input timeseries.\nEstimate changes of an indicator by sliding a window of the change metric over the indicator timeseries.\n\nIf t (the time vector of x), is not provided, it is assumed t = eachindex(x).\n\nReturn the output as WindowedIndicatorResults which can be given to significant_transitions to deduce which possible transitions are statistically significant using a variety of significance tests.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.WindowedIndicatorResults","page":"API","title":"TransitionsInTimeseries.WindowedIndicatorResults","text":"WindowedIndicatorResults\n\nA struct containing the output of estimate_transitions used with WindowedIndicatorConfig. It can be used for further analysis, visualization, or given to significant_transitions.\n\nIt has the following fields that the user may access\n\nx: the input timeseries.\nt: the time vector of the input timeseries.\nindicators::Vector{Function}: indicators used in the processing.\nx_indicator, the indicator timeseries (matrix with each column one indicator).\nt_indicator, the time vector of the indicator timeseries.\nchange_metrics::Vector{Function}: change metrics used in the processing.\nx_change, the change metric timeseries (matrix with each column one change metric).\nt_change, the time vector of the change metric timeseries.\n\n\n\n\n\n","category":"type"},{"location":"api/#Significance-testing","page":"API","title":"Significance testing","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SurrogatesSignificance\nsignificant_transitions","category":"page"},{"location":"api/#TransitionsInTimeseries.SurrogatesSignificance","page":"API","title":"TransitionsInTimeseries.SurrogatesSignificance","text":"SurrogatesSignificance <: TransitionsSignificance\nSurrogatesSignificance(; surrogate = RandomFourier(), n = 10_000, tail = :both, rng)\n\nA configuration struct containing instructions on how to test for significance in the function significant_transitions when combined with the output of estimate_transitions.\n\nDescription\n\nWhen used with WindowedIndicatorResults, significance is estimated as follows: n surrogates from the input timeseries are generated using surrogate, which is any Surrogate subtype provided by TimeseriesSurrogates.jl. For each surrogate, the indicator and then change metric timeseries is extracted. The values of the surrogate change metrics form a distribution of values (one at each time point). The value of the original change metric is compared to that of the surrogate distribution and a p-value is extracted according to the specified tail.\n\nthe p-value is simply the proportion of surrogate values that exceed (for tail = :right) or subseed (tail = :left) the discriminatory statistic computed from the input data. Use tail = :right if the surrogate data are expected to have higher discriminatory statistic values. This is the case for statistics that quantify entropy. For statistics that quantify autocorrelation, use tail = :right instead. For anything else, use the default tail = :both.\n\nAn iterable of tail values can also be given, in which case a specific tail is used for each change metric in WindowedIndicatorResults.\n\nKeyword rng = Random.default_rng() may specify a random number generator for the surrogates.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.significant_transitions","page":"API","title":"TransitionsInTimeseries.significant_transitions","text":"significant_transitions(res::WindowedIndicatorResults, signif::SurrogatesSignificance)\n\nEstimate significant transtions in res using the method described by SurrogatesSignificance. Return pvalues, a matrix with identical size as res.x_change. It contains the associated p-value timeseries for each change metric (each column).\n\n\n\n\n\n","category":"function"},{"location":"api/#indicators","page":"API","title":"Indicators","text":"","category":"section"},{"location":"api/#Value-distribution","page":"API","title":"Value distribution","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Statistics.mean(::Any)\nStatsBase.skewness\nStatsBase.kurtosis","category":"page"},{"location":"api/#Statistics.mean-Tuple{Any}","page":"API","title":"Statistics.mean","text":"mean(itr)\n\nCompute the mean of all elements in a collection.\n\nnote: Note\nIf itr contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the mean of non-missing values.\n\nExamples\n\njulia> using Statistics\n\njulia> mean(1:20)\n10.5\n\njulia> mean([1, missing, 3])\nmissing\n\njulia> mean(skipmissing([1, missing, 3]))\n2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsBase.skewness","page":"API","title":"StatsBase.skewness","text":"skewness(v, [wv::AbstractWeights], m=mean(v))\n\nCompute the standardized skewness of a real-valued array v, optionally specifying a weighting vector wv and a center m.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsBase.kurtosis","page":"API","title":"StatsBase.kurtosis","text":"kurtosis(v, [wv::AbstractWeights], m=mean(v))\n\nCompute the excess kurtosis of a real-valued array v, optionally specifying a weighting vector wv and a center m.\n\n\n\n\n\n","category":"function"},{"location":"api/#Critical-Slowing-Down","page":"API","title":"Critical Slowing Down","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Statistics.var(::AbstractArray)\nar1_whitenoise","category":"page"},{"location":"api/#Statistics.var-Tuple{AbstractArray}","page":"API","title":"Statistics.var","text":"var(itr; corrected::Bool=true, mean=nothing[, dims])\n\nCompute the sample variance of collection itr.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of itr is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating sum((itr .- mean(itr)).^2) / (length(itr) - 1). If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n is the number of elements in itr.\n\nIf itr is an AbstractArray, dims can be provided to compute the variance over dimensions.\n\nA pre-computed mean may be provided. When dims is specified, mean must be an array with the same shape as mean(itr, dims=dims) (additional trailing singleton dimensions are allowed).\n\nnote: Note\nIf array contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the variance of non-missing values.\n\n\n\n\n\n","category":"method"},{"location":"api/#TransitionsInTimeseries.ar1_whitenoise","page":"API","title":"TransitionsInTimeseries.ar1_whitenoise","text":"ar1_whitenoise(x::AbstractVector)\n\nReturn the AR1 regression coefficient θ of a time series x. Computation based on the analytic solution of the least-square parameter estimation:\n\ntheta = sum_i=2^n x_i  x_i-1  sum_i=2^n x_i-1^2\n\n\n\n\n\n","category":"function"},{"location":"api/#Spectrum","page":"API","title":"Spectrum","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LowfreqPowerSpectrum","category":"page"},{"location":"api/#TransitionsInTimeseries.LowfreqPowerSpectrum","page":"API","title":"TransitionsInTimeseries.LowfreqPowerSpectrum","text":"LowfreqPowerSpectrum(; q_lofreq = 0.1)\n\nReturn a PrecomputableFunction containing all the necessary fields to generate a PrecomputedLowfreqPowerSpectrum. The latter can be initialized by precompute:\n\nlfps = precompute( LowfreqPowerSpectrum() )\n\nKeyword arguments:\n\nq_lofreq: a number between 0 and 1 that characterises which portion of the\n\nfrequency spectrum is considered to be low. For instance, q_lofreq = 0.1 implies  that the lowest 10% of frequencies are considered to be the low ones.\n\n\n\n\n\n","category":"type"},{"location":"api/#Nonlinear-dynamics","page":"API","title":"Nonlinear dynamics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Indicators that come from nonlinear timeseries analysis and quantify some entropy-based dynamic quantity in the timeseries. They are provided by the ComplexityMeasures.jl package, that lists 100s of possible such indicators. Here we only provide an indicator out of the box for the permutation entropy, but building something similar is trivial:","category":"page"},{"location":"api/","page":"API","title":"API","text":"function permutation_entropy(; m = 3, τ = 1)\n    est = SymbolicPermutation(; m, τ)\n    return x -> entropy_normalized(est, x)\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"permutation_entropy\nentropy","category":"page"},{"location":"api/#TransitionsInTimeseries.permutation_entropy","page":"API","title":"TransitionsInTimeseries.permutation_entropy","text":"permutation_entropy(; m = 3, τ = 1) → f\n\nReturn a function that given timeseries x it computes the normalized permutation entropy of order m with time delay τ.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsBase.entropy","page":"API","title":"StatsBase.entropy","text":"entropy(p, [b])\n\nCompute the entropy of a collection of probabilities p, optionally specifying a real number b such that the entropy is scaled by 1/log(b). Elements with probability 0 or 1 add 0 to the entropy.\n\n\n\n\n\n","category":"function"},{"location":"api/#change_metrics","page":"API","title":"Change metrics","text":"","category":"section"},{"location":"api/#Slope","page":"API","title":"Slope","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"kendalltau\nspearman\nRidgeRegressionSlope","category":"page"},{"location":"api/#TransitionsInTimeseries.kendalltau","page":"API","title":"TransitionsInTimeseries.kendalltau","text":"kendalltau(x::AbstractVector)\n\nCompute the kendall-τ correlation coefficient of the time series x. kendalltau can be used as a change metric focused on trend.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.spearman","page":"API","title":"TransitionsInTimeseries.spearman","text":"spearman(x::AbstractVector)\n\nCompute the spearman correlation coefficient of the time series x. spearman can be used as a change metric focused on trend.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.RidgeRegressionSlope","page":"API","title":"TransitionsInTimeseries.RidgeRegressionSlope","text":"RidgeRegressionSlope(; lambda = 0.0) → rr\n\nReturn a PrecomputableFunction containing all the necessary fields to generate a PrecomputedRidgeRegressionSlope. rr can be used as a change metric focused on trend.\n\nlambda is a regularization constant, usually between 0 and 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#Value-distribution-differences","page":"API","title":"Value distribution differences","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"difference_of_means","category":"page"},{"location":"api/#TransitionsInTimeseries.difference_of_means","page":"API","title":"TransitionsInTimeseries.difference_of_means","text":"difference_of_means(x::AbstractArray)\n\nReturn the absolute difference of the means of the first and second halfs of x. difference_of_means can be used as a change metric focused on value differences. Creating similar statistical differences using other moments instead of mean is trivial. In fact, the source of difference_of_means is just:\n\n# assumes 1-based indexing\nn = length(x)\nx1 = view(x, 1:n÷2)\nx2 = view(x, (n÷2 + 1):n)\nreturn abs(mean(x1) - mean(x2))\n\ndifference_of_means can also sensibly be used for windows of size 2, in which case the change metric timeseries is the same as the abs.(diff(...)) of the indicator timeseries.\n\n\n\n\n\n","category":"function"},{"location":"api/#own_indicator","page":"API","title":"Make your own indicator/metric!","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The only difference between what is an \"indicator\" and what is a \"change metric\" is purely conceptual. As far as the code base of TransitionsInTimeseries.jl is concerned, they are both functions f: x::AbstractVector{Real} -> f(x)::Real. As a user you may give any such function for an indicator or change metric.","category":"page"},{"location":"api/","page":"API","title":"API","text":"There are situations where you may optimize such a function based on knowledge of input x type and length.","category":"page"},{"location":"api/","page":"API","title":"API","text":"TODO: Here explain how to use precomputable functions","category":"page"},{"location":"api/","page":"API","title":"API","text":"PrecomputableFunction\nprecompute","category":"page"},{"location":"api/#TransitionsInTimeseries.PrecomputableFunction","page":"API","title":"TransitionsInTimeseries.PrecomputableFunction","text":"PrecomputableFunction\n\nSupertype of structs containing the necessary field to precompute a ::Function by:\n\nprecompute(f::PrecomputableFunction, t)\n\n\n\n\n\n","category":"type"},{"location":"api/#Surrogates","page":"API","title":"Surrogates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"For the surrogate generation, you can use any subtype of Surrogate defined in Timeseriessurrogates.jl.","category":"page"},{"location":"api/#Sliding-windows","page":"API","title":"Sliding windows","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"WindowViewer\nwindowmap\nwindowmap!","category":"page"},{"location":"api/#TransitionsInTimeseries.WindowViewer","page":"API","title":"TransitionsInTimeseries.WindowViewer","text":"WindowViewer(x; width, stride)\n\nInitialize an iterator that generates views over the given timeseries x based on a window with a given width, incrementing the window views with the given stride. You can use this directly with map, such as map(std, WindowViewer(x, ...)) would give you the moving-window-timeseries of the std of x.\n\nIf not given, the keywords width, stride are taken as default_window_width(x) and 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.windowmap","page":"API","title":"TransitionsInTimeseries.windowmap","text":"windowmap(f::Function, x::AbstractVector; kwargs...) → mapped_f\n\nA shortcut for first generating a wv = WindowViewer(x; kwargs...) and then applying mapped_f = map(f, wv). If x is accompanied by a time vector t, you probably also want to call this function with t instead of x and with one of mean, midpoint, midvalue as f to obtain a time vector for the mapped_f output.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.windowmap!","page":"API","title":"TransitionsInTimeseries.windowmap!","text":"windowmap!(f::Function, out, x::AbstractVector; kwargs...)\n\nSame as windowmap, but writes the output in-place in out.\n\n\n\n\n\n","category":"function"},{"location":"api/#Load-data","page":"API","title":"Load data","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"load_linear_vs_doublewell()","category":"page"},{"location":"api/#TransitionsInTimeseries.load_linear_vs_doublewell-Tuple{}","page":"API","title":"TransitionsInTimeseries.load_linear_vs_doublewell","text":"load_linear_vs_doublewell()\n\nLoad prototypical data from a linear and a double-well model to test some indicators.\n\n\n\n\n\n","category":"method"},{"location":"#TransitionsInTimeseries.jl","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"","category":"section"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"(Image: TransitionsInTimeseries.jl)","category":"page"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"TransitionsInTimeseries","category":"page"},{"location":"#TransitionsInTimeseries","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries","text":"TransitionsInTimeseries.jl\n\n(Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that can estimate indicators of transitions (from one dynamic regime or stable state to another) in timeseries. Also bundles the indicators with significance testing via surrogate analysis using TimeseriesSurrogates.jl. Alternative names for this package could have been: Early Warning Signals / Resilience Indicators / Regime-Shift Identifiers / Change-Point Detectors, or however else you want to call them!\n\nThis package is currently under active development and not yet registered in the Julia general registry. To install it, first go into package-manager mode in the Julia REPL (press ]) and then run\n\nadd https://github.com/JuliaDynamics/TransitionsInTimeseries.jl\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"info: Star us on GitHub!\nIf you have found this package useful, please consider starring it on GitHub. This gives us an accurate lower bound of the (satisfied) user count.","category":"page"},{"location":"#content","page":"TransitionsInTimeseries.jl","title":"Content","text":"","category":"section"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"Multi-stable systems can display abrupt transitions between two stability regimes. To predict such transitions in real-world systems solely based on data, mathematical tools have been developed in the last decades. Numerous terminologies have been used for them, such as early warning signals, resilience indicators, regime-shift identifiers, change-point detection and transition indicators. TransitionsInTimeseries.jl sticks to the latter terminology and provides an interface that:","category":"page"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"Allows a fast computation of common transition indicators with a couple of lines, as demonstrated in the example section.\nMakes the surrogate analysis to test for significance under the hub.\nCan be easily extended by any user without touching the source code.\nReduces the programming overhead for any researcher willing to benchmark new methods.\nEases the reproducibility thanks to a clear syntax, a simple installation and RNG-seeded surrogate generation.\nIncreases trustworthiness thanks to a large test suite.","category":"page"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"info: Similar projects\nAn R toolbox and a Python library already exist. However, we believe that they are difficult to extend for the user. Furthermore, they do not offer a native performant code, as here allowed by the use of Julia.","category":"page"},{"location":"#approaches","page":"TransitionsInTimeseries.jl","title":"Approaches","text":"","category":"section"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"Over the last decades, research on transition indicators has largely focused on Critical Slowing Down (CSD). CSD is observed when a system approaches a Hopf, a transcritical or a fold bifurcation and consists in a resilience loss of the system. For instance this can be diagnosed by an increase of the variance and the AR1-regression coefficient, as demonstrated in the example section. However, we emphasize that this is one out of many possible approaches for obtaining transition indicators. Recent work has explored new approaches relying on nonlinear dynamics or machine learning. TransitionsInTimeseries.jl is designed to allow these cutting-edge methods and foster the development of new ones.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#workflow","page":"Tutorial","title":"Workflow","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Computing transition indicators consists of the following steps:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Doing any pre-processing of raw data first such as detrending (not part of TransitionsInTimeseries.jl). This yields the input timeseries.\nEstimating the timeseries of an indicator by sliding a window over the input timeseries.\nComputing the changes of the indicator by sliding a window over its timeseries.\nGenerating many surrogates that preserve important statistical properties of the original timeseries.\nPerforming step 2 and 3 for the surrogate timeseries.\nChecking whether the indicator change timeseries of the real timeseries shows a significant feature (trend, jump or anything else) when compared to the surrogate data.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These steps are illustrated one by one in the tutorial below, and then summarized in the convenient API that TransitionsInTimeseries.jl exports.","category":"page"},{"location":"tutorial/#example_stepbystep","page":"Tutorial","title":"Tutorial – Educational","text":"","category":"section"},{"location":"tutorial/#Raw-input-data","page":"Tutorial","title":"Raw input data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let us load data from a bistable nonlinear model subject to noise and to a gradual change of the forcing that leads to a transition. Furthermore, we also load data from a linear model, which is by definition monostable and therefore incapable of transitioning. This is done to control the rate of false positives, a common problem that can emerge when looking for transition indicators. The models are governed by:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dfracmathrmdx_lmathrmdt = - x_l - 1 + f(t) + n(t) \ndfracmathrmdx_nlmathrmdt = - x_nl^3 + x_nl + f(t) + n(t)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"with x_l the state of the linear model, x_nl the state of the bistable model, f the forcing and n the noise. For f=0 they both display an equilibrium point at x=-1. However, the bistable model also displays a further equilibrium point at x=1. Loading (and visualizing with Makie) such prototypical data to test some indicators can be done by simply running:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TransitionsInTimeseries, CairoMakie\n\nt, x_linear, x_nlinear = load_linear_vs_doublewell()\nfig, ax = lines(t, x_nlinear)\nlines!(ax, t, x_linear)\nax.title = \"raw data\"\nfig","category":"page"},{"location":"tutorial/#Preprocessing","page":"Tutorial","title":"Preprocessing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Not part of TransitionsInTimeseries.jl\nAny timeseries pre-processing, such as the de-trending step we do here, is not part of TransitionsInTimeseries.jl and is the responsibility of the researcher.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The nonlinear system clearly displays a transition between two stability regimes. To forecast such transition, we analyze the fluctuations of the timeseries around the tracked attractor. Therefore, a detrending step is needed - here simply obtained by building the difference of the timeseries with lag 1.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"x_l_fluct = diff(x_linear)\nx_nl_fluct = diff(x_nlinear)\ntfluct = t[2:end]\n\nfig, ax = lines(tfluct, x_l_fluct)\nlines!(ax, tfluct, x_nl_fluct .+ 0.05)\nax.title = \"input timeseries\"\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"At this point, x_l_fluct and x_nl_fluct are considered the input timeseries.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Detrending in Julia\nDetrending can be performed in many ways. A wide range of Julia packages exists to perform smoothing such as Loess.jl or DSP.jl. There the detrending step consists of subtracting the smoothed signal from the original one.","category":"page"},{"location":"tutorial/#Indicator-timeseries","page":"Tutorial","title":"Indicator timeseries","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can then compute the values of some \"indicator\" (a Julia function that inputs a timeseries and outputs a number). An indicator should be a quantity that is likely to change if a transition occurs in the timeseries. We compute indicators by applying a sliding window over the input timeseries, determined by the width and the stride with which it is applied. Here we demonstrate this computation with the AR1-regression coefficient (under white-noise assumption), implemented as ar1_whitenoise:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"indicator = ar1_whitenoise\nindicator_window = (width = 400, stride = 1)\n\n# By mapping `last::Function` over a windowviewer of the time vector, we obtain the last time step of each window.\n# This therefore only uses information from `k-width` to `k` at time step `k`.\n# Alternatives: `first::Function`, `midpoint:::Function`.\nt_indicator = windowmap(last, tfluct; indicator_window...)\nindicator_l = windowmap(indicator, x_l_fluct; indicator_window...)\nindicator_nl = windowmap(indicator, x_nl_fluct; indicator_window...)\n\nfig, ax = lines(t_indicator, indicator_l)\nlines!(ax, t_indicator, indicator_nl)\nax.title = \"indicator timeseries\"\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The lines plotted above are the indicator timeseries.","category":"page"},{"location":"tutorial/#Change-metric-timeseries","page":"Tutorial","title":"Change metric timeseries","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"From here, we process the indicator timeseries to quantify changes in it. This step is in essence the same as before: we apply some function over a sliding window of the indicator timeseries. We call this new timeseries the change metric timeseries. In the example here, the change metric we will employ will be the slope (over a sliding window), calculated via means of a RidgeRegressionSlope:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"change_window = (width = 30, stride = 1)\nridgereg = RidgeRegressionSlope(lambda = 0.0)\nprecompridgereg = precompute(ridgereg, t[1:change_window.width])\n\nt_change = windowmap(last, t_indicator; change_window...)\nchange_l = windowmap(precompridgereg, indicator_l; change_window...)\nchange_nl = windowmap(precompridgereg, indicator_nl; change_window...)\n\nfig, ax = lines(t_change, change_l)\nlines!(ax, t_change, change_nl)\nax.title = \"change metric timeseries\"\nfig","category":"page"},{"location":"tutorial/#Timeseries-surrogates","page":"Tutorial","title":"Timeseries surrogates","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected from Critical Slowing Down, an increase of the AR1-regression coefficient can be observed. Although eyeballing the timeseries might already be suggestive, we want a rigorous framework for testing for significance.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In TransitionsIdentifiers.jl we perform significance testing using the method of timeseries surrogates and the TimeseriesSurrogates.jl Julia package. This has the added benefits of flexibility in choosing the surrogate generation method, reproducibility, and automation. Note that TimeseriesSurrogates is re-exported by TransitionsInTimeseries, so that you don't have to using both of them.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To illustrate the surrogate, we compare the change metric computed from the bistable timeseries what that computed from a surrogate of the same timeseries.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Generate Fourier random-phase surrogates\nusing Random: Xoshiro\ns = surrogate(x_nl_fluct, RandomFourier(), Xoshiro(123))\nfig, ax = lines(tfluct, x_nl_fluct; color = Cycled(2))\nlines!(ax, tfluct, s .- 0.05; color = Cycled(3))\nax.title = \"real signal vs. surrogate(s)\"\n\n# compute and plot indicator and change metric\nindicator_s = windowmap(indicator, s; indicator_window...)\nchange_s = windowmap(precompridgereg, indicator_s; change_window...)\n\nax, = lines(fig[1,2], t_change, change_nl; color = Cycled(2), label = \"nonlin\")\nlines!(ax, t_change, change_s; color = Cycled(3), label = \"surrogate\")\naxislegend()\nax.title = \"change metric\"\n\nfig","category":"page"},{"location":"tutorial/#Quantifying-significance","page":"Tutorial","title":"Quantifying significance","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To quantify the significance of the values of the change metric timeseries we perform a standard surrogate test by computing the p-value w.r.t. the change metrics of thousands of surrogates of the input timeseries. A low p-value (typically p<0.05) is commonly considered as significant. To visualize significant trends, we plot the p-value vs. time:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"n_surrogates = 1_000\nfig = Figure()\naxl = Axis(fig[1,1]; title = \"linear\")\naxnl = Axis(fig[1,2]; title = \"nonlinear\")\naxsigl = Axis(fig[2,1])\naxsignl = Axis(fig[2,2])\n\nfor (j, ax, axsig, x) in zip(1:2, (axl, axnl), (axsigl, axsignl), (x_l_fluct, x_nl_fluct))\n\n    orig_change = j == 1 ? change_l : change_nl\n    sgen = surrogenerator(x, RandomFourier(), Xoshiro(123))\n    pval = zeros(length(change_s))\n\n    # Collect all surrogate change metrics\n    for i in 1:n_surrogates\n        s = sgen()\n        indicator_s = windowmap(indicator, s; indicator_window...)\n        change_s = windowmap(precompridgereg, indicator_s; change_window...)\n        pval += orig_change .< change_s\n    end\n\n    pval ./= n_surrogates\n    lines!(ax, t_change, orig_change; color = Cycled(j))\n    lines!(axsig, t_change, pval; color = Cycled(j+2))\nend\n\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected, the data generated by the nonlinear model displays a significant increase of the AR1-regression coefficient before the transition, which is manifested by a low p-value. In contrast, the data generated by the linear model does not show anything similar.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Performing the step-by-step analysis of transition indicators is possible and might be preferred for users wanting high flexibility. However, this results in a substantial amount of code. We therefore provide convenience functions that wrap this analysis, as shown in the next section.","category":"page"},{"location":"tutorial/#example_fastforward","page":"Tutorial","title":"Tutorial – TransitionsInTimeseries.jl","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TransitionsInTimeseries.jl wraps this typical workflow into a simple, extendable, and modular API that researchers can use with little effort. In addition, it allows performing the same analysis for several indicators / change metrics in one go.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The interface is simple, and directly parallelizes the Workflow. It is based on the creation of a TransitionsSurrogatesConfig, which contains a list of indicators, and corresponding metrics, to use for doing the above analysis. It also specifies what kind of surrogates to generate.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The following blocks illustrate how the above extensive example is re-created in TransitionsInTimeseries.jl","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TransitionsInTimeseries, CairoMakie\n\nt, x_linear, x_nlinear = load_linear_vs_doublewell()\n\n# input timeseries and time\ninput = x_nl_fluct = diff(x_nlinear)\nt = t[2:end]\n\nfig, ax = lines(t, input)\nax.title = \"input timeseries\"\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To perform all of the above analysis we follow a 2-step process.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Step 1, we decide what indicators and change metrics to use in WindowedIndicatorConfig and apply those via a sliding window to the input timeseries using estimate_transitions.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# These indicators are suitable for Critical Slowing Down\nindicators = (var, ar1_whitenoise)\n\n# use the ridge regression slope for both indicators\nchange_metrics = RidgeRegressionSlope()\n\n# choices go into a configuration struct\nconfig = WindowedIndicatorConfig(indicators, change_metrics;\n    width_ind = 400, width_cha = 30, whichtime = last\n)\n\n# choices are processed\nresults = estimate_transitions(config, input, t)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"From result we can plot the change metric timeseries","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fig, ax = lines(t, input; color = Cycled(2), label = \"input\")\naxpval, = scatter(fig[2,1], results.t_change, results.x_change[:, 1]; color = Cycled(3), label = \"var slopes\")\naxpval, = scatter(fig[3,1], results.t_change, results.x_change[:, 2]; color = Cycled(4), label = \"ar1 slopes\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Step 2 is to estimate significance using SurrogatesSignificance and the function significant_transitions.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"signif = SurrogatesSignificance(n = 1000, tail = :both)\npvalues = significant_transitions(results, signif)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"So now we can plot the p-values corresponding to each timeseries change metric","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fig, ax = lines(t, input; color = Cycled(2), label = \"input\")\naxpval, = scatter(fig[2,1], results.t_change, pvalues[:, 1]; color = Cycled(3), label = \"var p-values\")\nscatter!(axpval, results.t_change, pvalues[:, 2]; color = Cycled(4), label = \"ar1 p-values\")\naxislegend(axpval)\nxlims!(ax, 0, 50)\nxlims!(axpval, 0, 50)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can convert the p-values into flags by thresholding. Here we want the time points where both p-values are simultaneously below 0.05.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pthres = pvalues .< 0.05\nflags = vec(reduce(&, pthres; dims = 2))\n\nvlines!(ax, results.t_change[flags]; label = \"flags\", color = (\"black\", 0.1))\naxislegend(ax)\nfig","category":"page"}]
}
