var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Main-analysis-functions","page":"API","title":"Main analysis functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"WindowedIndicatorConfig\nestimate_indicator_changes\nWindowedIndicatorResults","category":"page"},{"location":"api/#TransitionsInTimeseries.WindowedIndicatorConfig","page":"API","title":"TransitionsInTimeseries.WindowedIndicatorConfig","text":"WindowedIndicatorConfig(indicators, change_metrics; kwargs...) → config\n\nA configuration struct for TransitionsInTimeseries.jl that collects what indicators and corresponding metrics to use in the estimate_indicator_changes.\n\nindicators is a tuple of indicators (or a single indicator). change_metrics is also a tuple or a single function. If a single function, the same change metric is used for all provided indicators. This way the analysis can be efficiently repeated for many indicators and/or change metrics.\n\nBoth indicators and change metrics are generic Julia functions that input an x::AbstractVector and output an s::Real. Any appropriate function may be given and see making custom indicators/change metrics in the documentation for more information.\n\nKeyword arguments\n\nwidth_ind::Int=100, stride_ind::Int=1: width and stride given to WindowViewer to compute the indicator from the input timeseries.\nwidth_cha::Int=50, stride_cha::Int=1: width and stride given to WindowViewer to compute the change metric timeseries from the indicator timeseries.\nwhichtime = midpoint: The time vector corresponding to the indicators / change metric timeseries is obtained from t in estimate_indicator_changes using the keyword whichtime. Options include:\nlast: use the last timepoint of each window\nmidpoint: use the mid timepoint of each time window\nfirst: use first timepoint of each window\nIn fact, the indicators time vector is computed simply via\nt_indicator = windowmap(whichtime, t; width_ind, stride_ind)\nt_change = windowmap(whichtime, t_indicator; width_cha, stride_cha)\nso any other function of the time window may be given to extract the time point itself, such as mean or median.\nT = Float64: Element type of input timeseries to initialize some computations.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.estimate_indicator_changes","page":"API","title":"TransitionsInTimeseries.estimate_indicator_changes","text":"estimate_indicator_changes(config::WindowedIndicatorConfig, x [,t]) → output\n\nEstimate possible transitions for input timeseries x using a sliding window approach as described by config:\n\nEstimate the timeseries of an indicator by sliding a window over the input timeseries.\nEstimate changes of an indicator by sliding a window of the change metric over the indicator timeseries.\n\nIf t (the time vector of x), is not provided, it is assumed t = eachindex(x).\n\nReturn the output as WindowedIndicatorResults which can be given to significant_transitions to deduce which possible transitions are statistically significant using a variety of significance tests.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.WindowedIndicatorResults","page":"API","title":"TransitionsInTimeseries.WindowedIndicatorResults","text":"WindowedIndicatorResults\n\nA struct containing the output of estimate_indicator_changes used with WindowedIndicatorConfig. It can be used for further analysis, visualization, or given to significant_transitions.\n\nIt has the following fields that the user may access\n\nx: the input timeseries.\nt: the time vector of the input timeseries.\nx_indicator, the indicator timeseries (matrix with each column one indicator).\nt_indicator, the time vector of the indicator timeseries.\nx_change, the change metric timeseries (matrix with each column one change metric).\nt_change, the time vector of the change metric timeseries.\nwim::WindowedIndicatorConfig, used for the analysis.\n\n\n\n\n\n","category":"type"},{"location":"api/#Significance-testing","page":"API","title":"Significance testing","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"significant_transitions\nTransitionsSignificance\nSurrogatesSignificance\nQuantileSignificance","category":"page"},{"location":"api/#TransitionsInTimeseries.significant_transitions","page":"API","title":"TransitionsInTimeseries.significant_transitions","text":"significant_transitions(res::WindowedIndicatorResults, signif::TransitionsSignificance)\n\nEstimate significant transtions in res using the method described by signif. Return flags, a Boolean matrix with identical size as res.x_change. It contains trues wherever a change metric of res is deemed significant.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.TransitionsSignificance","page":"API","title":"TransitionsInTimeseries.TransitionsSignificance","text":"TransitionsSignificance\n\nSupertype used to test for significance in significant_transitions. Valid subtypes are:\n\nSurrogatesSignificance.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.SurrogatesSignificance","page":"API","title":"TransitionsInTimeseries.SurrogatesSignificance","text":"SurrogatesSignificance <: TransitionsSignificance\nSurrogatesSignificance(; surrogate = RandomFourier(), n = 10_000, tail = :both, rng)\n\nA configuration struct for significance testing significant_transitions using timeseries surrogates.\n\nKeyword arguments\n\nsurromethod = RandomFourier(): method to generate surrogates\nn = 1000: how many surrogates to generate\nrng = Random.default_rng(): random number generator for the surrogates\np = 0.05: threshold for significance of the p-value\ntail = :both: tail type used, see below\n\nDescription\n\nWhen used with WindowedIndicatorResults, significance is estimated as follows: n surrogates from the input timeseries are generated using surromethod, which is any Surrogate subtype provided by TimeseriesSurrogates.jl. For each surrogate, the indicator and then change metric timeseries is extracted. The values of the surrogate change metrics form a distribution of values (one at each time point). The value of the original change metric is compared to that of the surrogate distribution and a p-value is extracted according to the specified tail. The p-value is compared with p to claim significance. After using SurrogatesSignificance, you may access the full p-values before thresholding in the field .pvalues (to e.g., threshold with different p).\n\nThe p-value is simply the proportion of surrogate change metric values that exceed (for tail = :right) or subseed (tail = :left) the original change metric at each given time point. Use tail = :left if the surrogate data are expected to have higher change metric, discriminatory statistic values. This is the case for statistics that quantify entropy. For statistics that quantify autocorrelation, use tail = :right instead. For anything else, use the default tail = :both. An iterable of tail values can also be given, in which case a specific tail is used for each change metric in WindowedIndicatorResults.\n\nNote that the raw p-values can be accessed in the field .pvalues, after calling the significant_transitions function with SurrogatesSignificance, in case you wish to obtain a different threshold of the p-values.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.QuantileSignificance","page":"API","title":"TransitionsInTimeseries.QuantileSignificance","text":"QuantileSignificance(; p = 0.95, tail = :right) <: TransitionsSignificance\n\nA configuration struct for significance testing significant_transitions. When used with WindowedIndicatorResults, significance is estimated as by comparing the value of each change metric with its p-quantile. Values that exceed the p-quantile (if tail = :right) or subseed the 1-p-quantile (if tail = :left) are deemed significant. If tail = :both then either condition is checked.\n\n\n\n\n\n","category":"type"},{"location":"api/#indicators","page":"API","title":"Indicators","text":"","category":"section"},{"location":"api/#Value-distribution","page":"API","title":"Value distribution","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Statistics.mean(::Any)\nStatsBase.skewness\nStatsBase.kurtosis","category":"page"},{"location":"api/#Statistics.mean-Tuple{Any}","page":"API","title":"Statistics.mean","text":"mean(itr)\n\nCompute the mean of all elements in a collection.\n\nnote: Note\nIf itr contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the mean of non-missing values.\n\nExamples\n\njulia> using Statistics\n\njulia> mean(1:20)\n10.5\n\njulia> mean([1, missing, 3])\nmissing\n\njulia> mean(skipmissing([1, missing, 3]))\n2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsBase.skewness","page":"API","title":"StatsBase.skewness","text":"skewness(v, [wv::AbstractWeights], m=mean(v))\n\nCompute the standardized skewness of a real-valued array v, optionally specifying a weighting vector wv and a center m.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsBase.kurtosis","page":"API","title":"StatsBase.kurtosis","text":"kurtosis(v, [wv::AbstractWeights], m=mean(v))\n\nCompute the excess kurtosis of a real-valued array v, optionally specifying a weighting vector wv and a center m.\n\n\n\n\n\n","category":"function"},{"location":"api/#Critical-Slowing-Down","page":"API","title":"Critical Slowing Down","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Statistics.var(::AbstractArray)\nar1_whitenoise","category":"page"},{"location":"api/#Statistics.var-Tuple{AbstractArray}","page":"API","title":"Statistics.var","text":"var(itr; corrected::Bool=true, mean=nothing[, dims])\n\nCompute the sample variance of collection itr.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of itr is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating sum((itr .- mean(itr)).^2) / (length(itr) - 1). If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n is the number of elements in itr.\n\nIf itr is an AbstractArray, dims can be provided to compute the variance over dimensions.\n\nA pre-computed mean may be provided. When dims is specified, mean must be an array with the same shape as mean(itr, dims=dims) (additional trailing singleton dimensions are allowed).\n\nnote: Note\nIf array contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the variance of non-missing values.\n\n\n\n\n\n","category":"method"},{"location":"api/#TransitionsInTimeseries.ar1_whitenoise","page":"API","title":"TransitionsInTimeseries.ar1_whitenoise","text":"ar1_whitenoise(x::AbstractVector)\n\nReturn the AR1 regression coefficient of a time series x by computing the analytic solution of the least-square parameter estimation under white-noise assumption for the data-generating process:\n\ntheta = sum_i=2^n x_i  x_i-1  sum_i=2^n x_i-1^2\n\n\n\n\n\n","category":"function"},{"location":"api/#Spectrum","page":"API","title":"Spectrum","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LowfreqPowerSpectrum","category":"page"},{"location":"api/#TransitionsInTimeseries.LowfreqPowerSpectrum","page":"API","title":"TransitionsInTimeseries.LowfreqPowerSpectrum","text":"LowfreqPowerSpectrum(; q_lofreq = 0.1)\n\nReturn a PrecomputableFunction containing all the necessary fields to generate a PrecomputedLowfreqPowerSpectrum. The latter can be initialized by precompute:\n\nlfps = precompute( LowfreqPowerSpectrum() )\n\nKeyword arguments:\n\nq_lofreq: a number between 0 and 1 that characterises which portion of the\n\nfrequency spectrum is considered to be low. For instance, q_lofreq = 0.1 implies  that the lowest 10% of frequencies are considered to be the low ones.\n\n\n\n\n\n","category":"type"},{"location":"api/#Nonlinear-dynamics","page":"API","title":"Nonlinear dynamics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Indicators that come from nonlinear timeseries analysis and quantify some entropy-based dynamic quantity in the timeseries. They are provided by the ComplexityMeasures.jl package, that lists 100s of possible such indicators. Here we only provide an indicator out of the box for the permutation entropy, but building something similar is trivial:","category":"page"},{"location":"api/","page":"API","title":"API","text":"function permutation_entropy(; m = 3, τ = 1)\n    est = SymbolicPermutation(; m, τ)\n    return x -> entropy_normalized(est, x)\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"permutation_entropy\nentropy","category":"page"},{"location":"api/#TransitionsInTimeseries.permutation_entropy","page":"API","title":"TransitionsInTimeseries.permutation_entropy","text":"permutation_entropy(; m = 3, τ = 1) → f\n\nReturn a function that given timeseries x it computes the normalized permutation entropy of order m with time delay τ.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsBase.entropy","page":"API","title":"StatsBase.entropy","text":"entropy(p, [b])\n\nCompute the entropy of a collection of probabilities p, optionally specifying a real number b such that the entropy is scaled by 1/log(b). Elements with probability 0 or 1 add 0 to the entropy.\n\n\n\n\n\n","category":"function"},{"location":"api/#change_metrics","page":"API","title":"Change metrics","text":"","category":"section"},{"location":"api/#Slope","page":"API","title":"Slope","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"kendalltau\nspearman\nRidgeRegressionSlope","category":"page"},{"location":"api/#TransitionsInTimeseries.kendalltau","page":"API","title":"TransitionsInTimeseries.kendalltau","text":"kendalltau(x::AbstractVector)\n\nCompute the kendall-τ correlation coefficient of the time series x. kendalltau can be used as a change metric focused on trend.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.spearman","page":"API","title":"TransitionsInTimeseries.spearman","text":"spearman(x::AbstractVector)\n\nCompute the spearman correlation coefficient of the time series x. spearman can be used as a change metric focused on trend.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.RidgeRegressionSlope","page":"API","title":"TransitionsInTimeseries.RidgeRegressionSlope","text":"RidgeRegressionSlope(; lambda = 0.0) → rr\n\nReturn a PrecomputableFunction containing all the necessary fields to generate a PrecomputedRidgeRegressionSlope. rr can be used as a change metric focused on trend.\n\nlambda is a regularization constant, usually between 0 and 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#Value-distribution-differences","page":"API","title":"Value distribution differences","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"difference_of_means","category":"page"},{"location":"api/#TransitionsInTimeseries.difference_of_means","page":"API","title":"TransitionsInTimeseries.difference_of_means","text":"difference_of_means(x::AbstractArray)\n\nReturn the absolute difference of the means of the first and second halfs of x. difference_of_means can be used as a change metric focused on value differences. Creating similar statistical differences using other moments instead of mean is trivial. In fact, the source of difference_of_means is just:\n\n# assumes 1-based indexing\nn = length(x)\nx1 = view(x, 1:n÷2)\nx2 = view(x, (n÷2 + 1):n)\nreturn abs(mean(x1) - mean(x2))\n\ndifference_of_means can also sensibly be used for windows of size 2, in which case the change metric timeseries is the same as the abs.(diff(...)) of the indicator timeseries.\n\n\n\n\n\n","category":"function"},{"location":"api/#own_indicator","page":"API","title":"Make your own indicator/metric!","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The only difference between what is an \"indicator\" and what is a \"change metric\" is purely conceptual. As far as the code base of TransitionsInTimeseries.jl is concerned, they are both functions f: x::AbstractVector{Real} -> f(x)::Real. As a user you may give any such function for an indicator or change metric.","category":"page"},{"location":"api/","page":"API","title":"API","text":"There are situations where you may optimize such a function based on knowledge of input x type and length.","category":"page"},{"location":"api/","page":"API","title":"API","text":"TODO: Here explain how to use precomputable functions","category":"page"},{"location":"api/","page":"API","title":"API","text":"PrecomputableFunction\nprecompute","category":"page"},{"location":"api/#TransitionsInTimeseries.PrecomputableFunction","page":"API","title":"TransitionsInTimeseries.PrecomputableFunction","text":"PrecomputableFunction\n\nSupertype of structs containing the necessary field to precompute a ::Function by:\n\nprecompute(f::PrecomputableFunction, t)\n\n\n\n\n\n","category":"type"},{"location":"api/#Surrogates","page":"API","title":"Surrogates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"For the surrogate generation, you can use any subtype of Surrogate defined in Timeseriessurrogates.jl.","category":"page"},{"location":"api/#Sliding-windows","page":"API","title":"Sliding windows","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"WindowViewer\nwindowmap\nwindowmap!","category":"page"},{"location":"api/#TransitionsInTimeseries.WindowViewer","page":"API","title":"TransitionsInTimeseries.WindowViewer","text":"WindowViewer(x; width, stride)\n\nInitialize an iterator that generates views over the given timeseries x based on a window with a given width, incrementing the window views with the given stride. You can use this directly with map, such as map(std, WindowViewer(x, ...)) would give you the moving-window-timeseries of the std of x.\n\nIf not given, the keywords width, stride are taken as default_window_width(x) and 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.windowmap","page":"API","title":"TransitionsInTimeseries.windowmap","text":"windowmap(f::Function, x::AbstractVector; kwargs...) → mapped_f\n\nA shortcut for first generating a wv = WindowViewer(x; kwargs...) and then applying mapped_f = map(f, wv). If x is accompanied by a time vector t, you probably also want to call this function with t instead of x and with one of mean, midpoint, midvalue as f to obtain a time vector for the mapped_f output.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.windowmap!","page":"API","title":"TransitionsInTimeseries.windowmap!","text":"windowmap!(f::Function, out, x::AbstractVector; kwargs...)\n\nSame as windowmap, but writes the output in-place in out.\n\n\n\n\n\n","category":"function"},{"location":"api/#Load-data","page":"API","title":"Load data","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"load_linear_vs_doublewell()","category":"page"},{"location":"api/#TransitionsInTimeseries.load_linear_vs_doublewell-Tuple{}","page":"API","title":"TransitionsInTimeseries.load_linear_vs_doublewell","text":"load_linear_vs_doublewell()\n\nLoad prototypical data from a linear and a double-well model to test some indicators.\n\n\n\n\n\n","category":"method"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"EditURL = \"examples.jl\"","category":"page"},{"location":"examples/#Examples-for-TransitionsInTimeseries.jl","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"","category":"section"},{"location":"examples/#Permutation-entropy-for-dynamic-regime-changes","page":"Examples for TransitionsInTimeseries.jl","title":"Permutation entropy for dynamic regime changes","text":"","category":"section"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"Permutation entropy is used frequently to detect a transition between one dynamic regime to another. It is useful when the mean and std. of the timeseries values are very similar between the two regimes, which would mean that common distribution-based indicators, or common critical-slowing-down based indicators, would fail.","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"This example will also explore different ways to test for significance that are arguably better suitable in such an application than the Tutorial's default of significance via random Fourier surrogates.","category":"page"},{"location":"examples/#Logistic-map-timeseries","page":"Examples for TransitionsInTimeseries.jl","title":"Logistic map timeseries","text":"","category":"section"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"A simple example of this is transitions from periodic to weakly chaotic to chaotic motion in the logistic map. First, let's generate a timeseries of the logistic map","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"using DynamicalSystemsBase\nusing CairoMakie\n\nlogistic_rule(u, p, t) = @inbounds SVector(p[1]*u[1]*(1 - u[1]))\nds = DeterministicIteratedMap(logistic_rule, [0.5], [1.0])\n\nr1 = 3.83\nr2 = 3.86\nN = 2000\nrs = range(r1, r2; length = N)\nx = zeros(N)\nfor (i, r) in enumerate(rs)\n    set_parameter!(ds, 1, r)\n    step!(ds)\n    x[i] = current_state(ds)[1]\nend","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"Plot it, using as time the parameter value (they coincide)","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"fig, ax = lines(rs, x; linewidth = 0.5)\nax.xlabel = \"r (time)\"\nax.ylabel = \"x\"\nfig","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"In this example there is a rather obvious transition to strongly chaotic motion at r ≈ 3.855. However, there is also a subtle transition to weak chaos at r ≈ 3.847. This transition is barely visible in the timeseries, and in fact many of the timeseries statistical properties remain identical.","category":"page"},{"location":"examples/#Using-a-simpler-change-metric","page":"Examples for TransitionsInTimeseries.jl","title":"Using a simpler change metric","text":"","category":"section"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"Now, let's compute and various indicators and their changes, focusing on the fourth indicator, the permutation entropy. We use order 4 here, because we know that to detect changes in a period m we would need an order ≥ m+1 permutation entropy.","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"using TransitionsInTimeseries\nindicators = (var, ar1_whitenoise, permutation_entropy(m = 4))\nindistrings = (\"var\", \"ar1\", \"pe\")","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"In this example there is no critical slowing down; instead, there is a sharp transition between periodic and chaotic motion. Hence, we shouldn't be using any trend-based change metrics. Instead, we will use the most basic change metric, difference_of_means. With this metric it also makes most sense to use as stride half the window width","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"metric = difference_of_means\n\nwidth_ind = N÷100\nwidth_cha = 20\nstride_cha = 10\n\nconfig = WindowedIndicatorConfig(indicators, metric;\n    width_ind, width_cha, stride_cha,\n)\n\nresults = estimate_indicator_changes(config, x, rs)","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"Let's now plot the change metrics of the indicators","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"function plot_change_metrics()\n    fig, ax = lines(rs, x; axis = (ylabel = \"input\",), figure = (resolution = (600, 600),))\n    hidexdecorations!(ax; grid = false)\n    # plot all change metrics\n    for (i, c) in enumerate(eachcol(results.x_change))\n        ax, = scatterlines(fig[i+1, 1], results.t_change, c;\n            axis = (ylabel = indistrings[i],), label = \"input\"\n        )\n        if i < 3\n            hidexdecorations!(ax; grid = false)\n        else\n            ax.xlabel = \"r (time)\"\n        end\n    end\n    return fig\nend\n\nfig = plot_change_metrics()","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"We already see the interesting results we expect: the permutation entropy shows a striking change as we go from periodic to weakly chaotic motion at r ≈ 3.847. (Remember: the plotted quantity is how much the indicator changes within a time window. High values mean large changes.)","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"Due to its construction, permutation entropy will have a spike for periodic data at the start of the timeseries, so we can safely ignore the spike at r ≈ 3.83.","category":"page"},{"location":"examples/#Significance-via-random-Fourier-surrogates","page":"Examples for TransitionsInTimeseries.jl","title":"Significance via random Fourier surrogates","text":"","category":"section"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"One way to test for significance would be via the standard way as in the Tutorial, utilizing surrogate timeseries and SurrogatesSignificance.","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"Let's do it here for an example, but, we have to be careful. It is crucial that for permutation entropy we use :right as the tail, because it is expected that the surrogates will have higher differences in the permutation entropy timeseries (because, if there is no dynamical change, the permutation entropy will stay the same, while in the surrogates there are always random fluctuations!","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"surromethod = RandomFourier()\n\n# Define a function because we will re-use later\nfunction overplot_surrogate_significance!(fig, surromethod, color = \"black\")\n\n    signif = SurrogatesSignificance(;\n        n = 1000, tail = [:both, :both, :right], surromethod\n    )\n    flags = significant_transitions(results, signif)\n\n    # and also plot the flags with same color\n    for (i, indicator) in enumerate(indicators)\n        # To make things visually clear, we will also plot some example surrogate\n        # timeseries for each indicator and change metric pair\n        for _ in 1:10\n            s = TimeseriesSurrogates.surrogate(x, surromethod)\n            p = windowmap(indicator, s; width = width_ind)\n            q = windowmap(metric, p; width = width_cha, stride = stride_cha)\n            lines!(fig[i+1, 1], results.t_change, q;  color = (color, 0.2), linewidth = 1)\n        end\n        # Plot the flags as vertical dashed lines\n        vlines!(fig[i+1, 1], results.t_change[flags[:, i]];\n            color = color, linestyle = :dash, linewidth = 3\n        )\n    end\n    # add a title to the figure with how we estimate significance\n    content(fig[1, 1]).title = \"surrogates: \"*string(nameof(typeof(surromethod)))\nend\n\nsurromethod = RandomFourier()\noverplot_surrogate_significance!(fig, surromethod)\n\nfig","category":"page"},{"location":"examples/#More-appropriate-surrogates","page":"Examples for TransitionsInTimeseries.jl","title":"More appropriate surrogates","text":"","category":"section"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"Using random Fourier surrogates does not make much sense in our application. Those surrogates perserve the power spectrum of the timeseries, but the power spectrum is a property integrated over the whole timeseries. It doesn't contain any information regarding a sharp transition at some point in the timeseries. A much better alternative is to use block-shuffled surrogates, which preserve the short term local temporal correlation in the timeseries and hence also preserve local short term sharp changes in the dynamic behavior.","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"surromethod = BlockShuffle(15)\nfig = plot_change_metrics()\noverplot_surrogate_significance!(fig, surromethod, \"red\")\nfig","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"The results are better for the variance and AR1 indicators. For the permutation entropy the results do not change because it already is an exceptionally well suited indicator for this application scenario. But in other cases where things are not as clear, or data are contaminated with noise, or we have shorter data, choosing a more suitable surrogate generator may make the difference between a false positive or not.","category":"page"},{"location":"examples/#Simpler-Significance","page":"Examples for TransitionsInTimeseries.jl","title":"Simpler Significance","text":"","category":"section"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"Arguably, exactly because we are using the difference_of_means as a change metric, we may want to be much less strict with our tests for significance. Instead of using SurrogatesSignificance we may use the simpler and much faster QuantileSignificance, which simply claims significant time points whenever a change metric exceeds some pre-defined quantile of its timeseries.","category":"page"},{"location":"examples/","page":"Examples for TransitionsInTimeseries.jl","title":"Examples for TransitionsInTimeseries.jl","text":"fig = plot_change_metrics()\nflags = significant_transitions(results, QuantileSignificance())\n\n# Plot the flags\nfor (i, indicator) in enumerate(indicators)\n    vlines!(fig[i+1, 1], results.t_change[flags[:, i]];\n        color = Cycled(3), linestyle = :dash, linewidth = 3\n    )\nend\ncontent(fig[1, 1]).title = \"significance from quantile\"\nfig","category":"page"},{"location":"#TransitionsInTimeseries.jl","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"","category":"section"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"(Image: TransitionsInTimeseries.jl)","category":"page"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"TransitionsInTimeseries","category":"page"},{"location":"#TransitionsInTimeseries","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries","text":"TransitionsInTimeseries.jl\n\n(Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that can estimate indicators of transitions (from one dynamic regime or stable state to another) in timeseries. Also bundles the indicators with significance testing via surrogate analysis using TimeseriesSurrogates.jl. Alternative names for this package could have been: Early Warning Signals / Resilience Indicators / Regime-Shift Identifiers / Change-Point Detectors, or however else you want to call them!\n\nThis package is currently under active development and not yet registered in the Julia general registry. To install it, first go into package-manager mode in the Julia REPL (press ]) and then run\n\nadd https://github.com/JuliaDynamics/TransitionsInTimeseries.jl\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"info: Star us on GitHub!\nIf you have found this package useful, please consider starring it on GitHub. This gives us an accurate lower bound of the (satisfied) user count.","category":"page"},{"location":"#content","page":"TransitionsInTimeseries.jl","title":"Content","text":"","category":"section"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"Multi-stable systems can display abrupt transitions between two stability regimes. To predict such transitions in real-world systems solely based on data, mathematical tools have been developed in the last decades. Numerous terminologies have been used for them, such as early warning signals, resilience indicators, regime-shift identifiers, change-point detection and transition indicators. TransitionsInTimeseries.jl sticks to the latter terminology and provides an interface that:","category":"page"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"Allows a fast computation of common transition indicators with a couple of lines, as demonstrated in the example section.\nMakes the surrogate analysis to test for significance under the hub.\nCan be easily extended by any user without touching the source code.\nReduces the programming overhead for any researcher willing to benchmark new methods.\nEases the reproducibility thanks to a clear syntax, a simple installation and RNG-seeded surrogate generation.\nIncreases trustworthiness thanks to a large test suite.","category":"page"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"info: Similar projects\nAn R toolbox and a Python library already exist. However, we believe that they are difficult to extend for the user. Furthermore, they do not offer a native performant code, as here allowed by the use of Julia.","category":"page"},{"location":"#approaches","page":"TransitionsInTimeseries.jl","title":"Approaches","text":"","category":"section"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"Over the last decades, research on transition indicators has largely focused on Critical Slowing Down (CSD). CSD is observed when a system approaches a Hopf, a transcritical or a fold bifurcation and consists in a resilience loss of the system. For instance this can be diagnosed by an increase of the variance and the AR1-regression coefficient, as demonstrated in the example section. However, we emphasize that this is one out of many possible approaches for obtaining transition indicators. Recent work has explored new approaches relying on nonlinear dynamics or machine learning. TransitionsInTimeseries.jl is designed to allow these cutting-edge methods and foster the development of new ones.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#workflow","page":"Tutorial","title":"Workflow","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Computing transition indicators consists of the following steps:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Doing any pre-processing of raw data first such as detrending (not part of TransitionsInTimeseries.jl). This yields the input timeseries.\nEstimating the timeseries of an indicator by sliding a window over the input timeseries.\nComputing the changes of the indicator by sliding a window over its timeseries.\nGenerating many surrogates that preserve important statistical properties of the original timeseries.\nPerforming step 2 and 3 for the surrogate timeseries.\nChecking whether the indicator change timeseries of the real timeseries shows a significant feature (trend, jump or anything else) when compared to the surrogate data.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These steps are illustrated one by one in the tutorial below, and then summarized in the convenient API that TransitionsInTimeseries.jl exports.","category":"page"},{"location":"tutorial/#example_stepbystep","page":"Tutorial","title":"Tutorial – Educational","text":"","category":"section"},{"location":"tutorial/#Raw-input-data","page":"Tutorial","title":"Raw input data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let us load data from a bistable nonlinear model subject to noise and to a gradual change of the forcing that leads to a transition. Furthermore, we also load data from a linear model, which is by definition monostable and therefore incapable of transitioning. This is done to control the rate of false positives, a common problem that can emerge when looking for transition indicators. The models are governed by:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dfracmathrmdx_lmathrmdt = - x_l - 1 + f(t) + n(t) \ndfracmathrmdx_nlmathrmdt = - x_nl^3 + x_nl + f(t) + n(t)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"with x_l the state of the linear model, x_nl the state of the bistable model, f the forcing and n the noise. For f=0 they both display an equilibrium point at x=-1. However, the bistable model also displays a further equilibrium point at x=1. Loading (and visualizing with Makie) such prototypical data to test some indicators can be done by simply running:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TransitionsInTimeseries, CairoMakie\n\nt, x_linear, x_nlinear = load_linear_vs_doublewell()\nfig, ax = lines(t, x_nlinear)\nlines!(ax, t, x_linear)\nax.title = \"raw data\"\nfig","category":"page"},{"location":"tutorial/#Preprocessing","page":"Tutorial","title":"Preprocessing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Not part of TransitionsInTimeseries.jl\nAny timeseries pre-processing, such as the de-trending step we do here, is not part of TransitionsInTimeseries.jl and is the responsibility of the researcher.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The nonlinear system clearly displays a transition between two stability regimes. To forecast such transition, we analyze the fluctuations of the timeseries around the tracked attractor. Therefore, a detrending step is needed - here simply obtained by building the difference of the timeseries with lag 1.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"x_l_fluct = diff(x_linear)\nx_nl_fluct = diff(x_nlinear)\ntfluct = t[2:end]\n\nfig, ax = lines(tfluct, x_l_fluct)\nlines!(ax, tfluct, x_nl_fluct .+ 0.05)\nax.title = \"input timeseries\"\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"At this point, x_l_fluct and x_nl_fluct are considered the input timeseries.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Detrending in Julia\nDetrending can be performed in many ways. A wide range of Julia packages exists to perform smoothing such as Loess.jl or DSP.jl. There the detrending step consists of subtracting the smoothed signal from the original one.","category":"page"},{"location":"tutorial/#Indicator-timeseries","page":"Tutorial","title":"Indicator timeseries","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can then compute the values of some \"indicator\" (a Julia function that inputs a timeseries and outputs a number). An indicator should be a quantity that is likely to change if a transition occurs in the timeseries. We compute indicators by applying a sliding window over the input timeseries, determined by the width and the stride with which it is applied. Here we demonstrate this computation with the AR1-regression coefficient (under white-noise assumption), implemented as ar1_whitenoise:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"indicator = ar1_whitenoise\nindicator_window = (width = 400, stride = 1)\n\n# By mapping `last::Function` over a windowviewer of the time vector, we obtain the last time step of each window.\n# This therefore only uses information from `k-width` to `k` at time step `k`.\n# Alternatives: `first::Function`, `midpoint:::Function`.\nt_indicator = windowmap(last, tfluct; indicator_window...)\nindicator_l = windowmap(indicator, x_l_fluct; indicator_window...)\nindicator_nl = windowmap(indicator, x_nl_fluct; indicator_window...)\n\nfig, ax = lines(t_indicator, indicator_l)\nlines!(ax, t_indicator, indicator_nl)\nax.title = \"indicator timeseries\"\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The lines plotted above are the indicator timeseries.","category":"page"},{"location":"tutorial/#Change-metric-timeseries","page":"Tutorial","title":"Change metric timeseries","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"From here, we process the indicator timeseries to quantify changes in it. This step is in essence the same as before: we apply some function over a sliding window of the indicator timeseries. We call this new timeseries the change metric timeseries. In the example here, the change metric we will employ will be the slope (over a sliding window), calculated via means of a RidgeRegressionSlope:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"change_window = (width = 30, stride = 1)\nridgereg = RidgeRegressionSlope(lambda = 0.0)\nprecompridgereg = precompute(ridgereg, t[1:change_window.width])\n\nt_change = windowmap(last, t_indicator; change_window...)\nchange_l = windowmap(precompridgereg, indicator_l; change_window...)\nchange_nl = windowmap(precompridgereg, indicator_nl; change_window...)\n\nfig, ax = lines(t_change, change_l)\nlines!(ax, t_change, change_nl)\nax.title = \"change metric timeseries\"\nfig","category":"page"},{"location":"tutorial/#Timeseries-surrogates","page":"Tutorial","title":"Timeseries surrogates","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected from Critical Slowing Down, an increase of the AR1-regression coefficient can be observed. Although eyeballing the timeseries might already be suggestive, we want a rigorous framework for testing for significance.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In TransitionsIdentifiers.jl we perform significance testing using the method of timeseries surrogates and the TimeseriesSurrogates.jl Julia package. This has the added benefits of flexibility in choosing the surrogate generation method, reproducibility, and automation. Note that TimeseriesSurrogates is re-exported by TransitionsInTimeseries, so that you don't have to using both of them.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To illustrate the surrogate, we compare the change metric computed from the bistable timeseries what that computed from a surrogate of the same timeseries.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Generate Fourier random-phase surrogates\nusing Random: Xoshiro\ns = surrogate(x_nl_fluct, RandomFourier(), Xoshiro(123))\nfig, ax = lines(tfluct, x_nl_fluct; color = Cycled(2))\nlines!(ax, tfluct, s .- 0.05; color = Cycled(3))\nax.title = \"real signal vs. surrogate(s)\"\n\n# compute and plot indicator and change metric\nindicator_s = windowmap(indicator, s; indicator_window...)\nchange_s = windowmap(precompridgereg, indicator_s; change_window...)\n\nax, = lines(fig[1,2], t_change, change_nl; color = Cycled(2), label = \"nonlin\")\nlines!(ax, t_change, change_s; color = Cycled(3), label = \"surrogate\")\naxislegend()\nax.title = \"change metric\"\n\nfig","category":"page"},{"location":"tutorial/#Quantifying-significance","page":"Tutorial","title":"Quantifying significance","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To quantify the significance of the values of the change metric timeseries we perform a standard surrogate test by computing the p-value w.r.t. the change metrics of thousands of surrogates of the input timeseries. A low p-value (typically p<0.05) is commonly considered as significant. To visualize significant trends, we plot the p-value vs. time:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"n_surrogates = 1_000\nfig = Figure()\naxl = Axis(fig[1,1]; title = \"linear\")\naxnl = Axis(fig[1,2]; title = \"nonlinear\")\naxsigl = Axis(fig[2,1])\naxsignl = Axis(fig[2,2])\n\nfor (j, ax, axsig, x) in zip(1:2, (axl, axnl), (axsigl, axsignl), (x_l_fluct, x_nl_fluct))\n\n    orig_change = j == 1 ? change_l : change_nl\n    sgen = surrogenerator(x, RandomFourier(), Xoshiro(123))\n    pval = zeros(length(change_s))\n\n    # Collect all surrogate change metrics\n    for i in 1:n_surrogates\n        s = sgen()\n        indicator_s = windowmap(indicator, s; indicator_window...)\n        change_s = windowmap(precompridgereg, indicator_s; change_window...)\n        pval += orig_change .< change_s\n    end\n\n    pval ./= n_surrogates\n    lines!(ax, t_change, orig_change; color = Cycled(j))\n    lines!(axsig, t_change, pval; color = Cycled(j+2))\nend\n\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected, the data generated by the nonlinear model displays a significant increase of the AR1-regression coefficient before the transition, which is manifested by a low p-value. In contrast, the data generated by the linear model does not show anything similar.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Performing the step-by-step analysis of transition indicators is possible and might be preferred for users wanting high flexibility. However, this results in a substantial amount of code. We therefore provide convenience functions that wrap this analysis, as shown in the next section.","category":"page"},{"location":"tutorial/#example_fastforward","page":"Tutorial","title":"Tutorial – TransitionsInTimeseries.jl","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TransitionsInTimeseries.jl wraps this typical workflow into a simple, extendable, and modular API that researchers can use with little effort. In addition, it allows performing the same analysis for several indicators / change metrics in one go.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The interface is simple, and directly parallelizes the Workflow. It is based on the creation of a WindowedIndicatorConfig, which contains a list of indicators, and corresponding metrics, to use for doing the above analysis.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The following blocks illustrate how the above extensive example is re-created in TransitionsInTimeseries.jl. First, let's load the timeseries again.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TransitionsInTimeseries, CairoMakie\n\nt, x_linear, x_nlinear = load_linear_vs_doublewell()\n\n# input timeseries and time\ninput = x_nl_fluct = diff(x_nlinear)\nt = t[2:end]\n\nfig, ax = lines(t, input)\nax.title = \"input timeseries\"\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To perform all of the above analysis we follow a 2-step process.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Step 1, we decide what indicators and change metrics to use in WindowedIndicatorConfig and apply those via a sliding window to the input timeseries using estimate_indicator_changes.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# These indicators are suitable for Critical Slowing Down\nindicators = (var, ar1_whitenoise)\n\n# use the ridge regression slope for both indicators\nchange_metrics = RidgeRegressionSlope()\n\n# choices go into a configuration struct\nconfig = WindowedIndicatorConfig(indicators, change_metrics;\n    width_ind = 400, width_cha = 30, whichtime = last\n)\n\n# choices are processed\nresults = estimate_indicator_changes(config, input, t)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"From result we can plot the change metric timeseries","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fig, ax = lines(t, input; color = Cycled(2), label = \"input\")\naxpval, = scatter(fig[2,1], results.t_change, results.x_change[:, 1]; color = Cycled(3), label = \"var slopes\")\naxpval, = scatter(fig[3,1], results.t_change, results.x_change[:, 2]; color = Cycled(4), label = \"ar1 slopes\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Step 2 is to estimate significance using SurrogatesSignificance and the function significant_transitions.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"signif = SurrogatesSignificance(n = 1000, tail = :both)\nflags = significant_transitions(results, signif)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If we want, we can also plot the p-values corresponding to each timeseries change metric","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fig, ax = lines(t, input; color = Cycled(2), label = \"input\")\naxpval, = scatter(fig[2,1], results.t_change, signif.pvalues[:, 1]; color = Cycled(3), label = \"var p-values\")\nscatter!(axpval, results.t_change, signif.pvalues[:, 2]; color = Cycled(4), label = \"ar1 p-values\")\naxislegend(axpval)\nxlims!(ax, 0, 50)\nxlims!(axpval, 0, 50)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"From the flags we can obtain the time points where both indicators show significance, via a simple reduction","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"flagsboth = vec(reduce(&, flags; dims = 2))\n\nvlines!(ax, results.t_change[flagsboth]; label = \"flags\", color = (\"black\", 0.1))\naxislegend(ax)\nfig","category":"page"}]
}
