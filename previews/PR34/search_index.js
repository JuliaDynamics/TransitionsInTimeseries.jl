var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Load-data","page":"API","title":"Load data","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"load_linear_vs_doublewell()","category":"page"},{"location":"api/#TransitionIndicators.load_linear_vs_doublewell-Tuple{}","page":"API","title":"TransitionIndicators.load_linear_vs_doublewell","text":"load_linear_vs_doublewell()\n\nLoad prototypical data from a linear and a double-well model to test some indicators.\n\n\n\n\n\n","category":"method"},{"location":"api/#Indicators-analysis","page":"API","title":"Indicators analysis","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"PrecomputableFunction\nprecompute_metrics\nIndicatorsConfig\nSignificanceConfig\nindicators_analysis\nIndicatorsResults","category":"page"},{"location":"api/#TransitionIndicators.PrecomputableFunction","page":"API","title":"TransitionIndicators.PrecomputableFunction","text":"PrecomputableFunction\n\nSupertype of structs containing the necessary field to precompute a ::Function by:\n\nprecompute(f::PrecomputableFunction, t)\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionIndicators.precompute_metrics","page":"API","title":"TransitionIndicators.precompute_metrics","text":"precompute_metrics(metrics::Vector, t::AbstractVector)\n\nPrecompute functions contained in metrics that can be precomputed based on the time vector t. Relies on abstract type PrecomputableFunction.\n\nThe output f::Vector{Function} contains the ready-to-use metrics.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionIndicators.IndicatorsConfig","page":"API","title":"TransitionIndicators.IndicatorsConfig","text":"IndicatorsConfig(t::AbstractVector, f::Function, indicators...; kwargs...)\n\nA configuration for computing indicators from timeseries with time t. Indicators are standard Julia functions that input an ::AbstractVector and output a ::Real. Any number of indicators can be given. Indicators typically used in the literature are listed in the documentation section Indicators.\n\nKeywords are propagated into WindowViewer to create a sliding window for estimating the indicators. The time vector resulting from the sliding window is obtained under the hood by:\n\nt_indicator = windowmap(f, t, kwargs...)\n\nCommon choices for f are:\n\nlast: use x[k-width:k] to estimate the indicator at time step k.\nmidpoint: use x[k-width÷2:k+width÷2] to estimate the indicator at time step k.\nfirst: use x[k:k+width] to estimate the indicator at time step k.\n\nAlong with SignificanceConfig it is given to indicators_analysis.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionIndicators.SignificanceConfig","page":"API","title":"TransitionIndicators.SignificanceConfig","text":"SignificanceConfig(indconfig, f, change_metrics...; kwargs...)\n\nA configuration for estimating a significant change of indicators based on a sliding window and and indconfig::IndicatorsConfig. The time vector resulting from the sliding window is obtained under the hood by:\n\nt_change = windowmap(f, indconfig.t_indicator, kwargs...)\n\nCommon choices for f are:\n\nlast: use x[k-width:k] to estimate the indicator change at time step k.\nmidpoint: use x[k-width÷2:k+width÷2] to estimate the indicator change\n\nat time step k.\n\nfirst: use x[k:k+width] to estimate the indicator change at time step k.\n\nAlong with IndicatorsConfig, SignificanceConfig is given to indicators_analysis.\n\nchange_metrics can be a single Julia function, in which case the same metric is applied over all indicators in IndicatorsConfig. change_metrics can also be many functions, each one for each indicator.\n\nKeyword arguments\n\nn_surrogates::Int = 10_000: how many surrogates to create.\nsurrogate_method::S = RandomFourier(): what method to use to create the surrogates. Any Surrogate subtype from TimeseriesSurrogates.jl is valid.\nrng::AbstractRNG = Random.default_rng()`: a random number generator for the surrogates. See the Julia manual for more.\nwidth::Int: width given to the WindowViewer of the indicator timeseries to estimate transient changes of the indicator.\nstride::Int: stride given to the WindowViewer of the indicator timeseries to estimate transient changes of the indicator.\ntail::Symbol: kind of tail test to do (one of :left, :right, :both).\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionIndicators.indicators_analysis","page":"API","title":"TransitionIndicators.indicators_analysis","text":"indicators_analysis(t, x, indicators::IndicatorsConfig, sigconfig::SignificanceConfig)\n\nPerform an analysis of transition indicators for input timeseries x with time vector t by specifying which indicators to use and with what sliding window (IndicatorsConfig), as well as how to measure significant changes in the indicators (SignificanceConfig). If t is not provided, it is assumed that t=eachindex(x).\n\nReturn the output as IndicatorsResults.\n\nThis function performs the analysis described in the documentation Example sections. It computes various indicators over sliding windows of x, and then computes change metrics of over sliding windows of the indicators. It does exactly the same computations for surrogates of x and use this result to check for significance of the change metrics by computing the p-value. The returned output contains all these computed timeseries.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionIndicators.IndicatorsResults","page":"API","title":"TransitionIndicators.IndicatorsResults","text":"IndicatorsResults\n\nA struct containing the output of indicators_analysis, which is the main computational part of TransitionIndicators.jl. It can be used for analysis and visualization purposes.\n\nIt has the following fields:\n\nx: the input timeseries.\nt: the time vector of the input timeseries.\nindicators::Vector{Function}: indicators used in the processing.\nx_indicator, the indicator timeseries (matrix with each column one indicator).\nt_indicator, the time vector of the indicator timeseries.\nchange_metrics::Vector{Function}: change metrics used in the processing.\nx_change, the change metric timeseries (matrix with each column one change metric).\nt_change, the time vector of the change metric timeseries.\npval, the p-value of the change metrics w.r.t. the surrogates. It is a 2-dimensional array, where first dimension = time, second dimension = change metric. I.e. pval[:, k] will give the time series of p-value of the k-th change metric.\n\n\n\n\n\n","category":"type"},{"location":"api/#Indicators","page":"API","title":"Indicators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Statistics.mean(::Any)\nStatistics.var(::AbstractArray)\nStatsBase.skewness\nStatsBase.kurtosis\nar1_whitenoise\nLowfreqPowerSpectrum\nPrecomputedLowfreqPowerSpectrum\nPermutationEntropy()\nPermutationEntropy(::AbstractVector)","category":"page"},{"location":"api/#Statistics.mean-Tuple{Any}","page":"API","title":"Statistics.mean","text":"mean(itr)\n\nCompute the mean of all elements in a collection.\n\nnote: Note\nIf itr contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the mean of non-missing values.\n\nExamples\n\njulia> using Statistics\n\njulia> mean(1:20)\n10.5\n\njulia> mean([1, missing, 3])\nmissing\n\njulia> mean(skipmissing([1, missing, 3]))\n2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.var-Tuple{AbstractArray}","page":"API","title":"Statistics.var","text":"var(itr; corrected::Bool=true, mean=nothing[, dims])\n\nCompute the sample variance of collection itr.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of itr is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating sum((itr .- mean(itr)).^2) / (length(itr) - 1). If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n is the number of elements in itr.\n\nIf itr is an AbstractArray, dims can be provided to compute the variance over dimensions.\n\nA pre-computed mean may be provided. When dims is specified, mean must be an array with the same shape as mean(itr, dims=dims) (additional trailing singleton dimensions are allowed).\n\nnote: Note\nIf array contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the variance of non-missing values.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsBase.skewness","page":"API","title":"StatsBase.skewness","text":"skewness(v, [wv::AbstractWeights], m=mean(v))\n\nCompute the standardized skewness of a real-valued array v, optionally specifying a weighting vector wv and a center m.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsBase.kurtosis","page":"API","title":"StatsBase.kurtosis","text":"kurtosis(v, [wv::AbstractWeights], m=mean(v))\n\nCompute the excess kurtosis of a real-valued array v, optionally specifying a weighting vector wv and a center m.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionIndicators.ar1_whitenoise","page":"API","title":"TransitionIndicators.ar1_whitenoise","text":"ar1_whitenoise(x::AbstractVector)\n\nReturn the AR1 regression coefficient θ of a time series x. Computation based on the analytic solution of the least-square parameter estimation:\n\n    hattheta = dfracsum_i=2^n x_i  x_i-1sum_i=2^n x_i-1^2\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionIndicators.LowfreqPowerSpectrum","page":"API","title":"TransitionIndicators.LowfreqPowerSpectrum","text":"LowfreqPowerSpectrum(; q_lofreq = 0.1)\n\nReturn a PrecomputableFunction containing all the necessary fields to generate a PrecomputedLowfreqPowerSpectrum. The latter can be initialized by precompute:\n\nlfps = precompute( LowfreqPowerSpectrum() )\n\nKeyword arguments:\n\nq_lofreq: a number between 0 and 1 that characterises which portion of the\n\nfrequency spectrum is considered to be low. For instance, q_lofreq = 0.1 implies  that the lowest 10% of frequencies are considered to be the low ones.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionIndicators.PrecomputedLowfreqPowerSpectrum","page":"API","title":"TransitionIndicators.PrecomputedLowfreqPowerSpectrum","text":"PrecomputedLowfreqPowerSpectrum(x::AbstractVector)\n\nA struct containing all the precomputed fields to efficiently perform repetitive computation of the low-frequency power spectrum (LFPS), a number between 0 and 1 that characterizes the amount of power contained in the low frequencies of the power density spectrum of x. Once lfps::PrecomputedLowfreqPowerSpectrum is initialized, it can be used as a function to obtain the LFPS of x::AbstractVector by:\n\nlfps(x)\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionIndicators.PermutationEntropy-Tuple{AbstractVector}","page":"API","title":"TransitionIndicators.PermutationEntropy","text":"PermutationEntropy(x::AbstractVector)\n\nReturn the permutation entropy of x. This computation breaks down in computing the entropy_normalized of a SymbolicPermutation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Change-metrics","page":"API","title":"Change metrics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"kendalltau\nspearman\nRidgeRegressionSlope\nPrecomputedRidgeRegressionSlope","category":"page"},{"location":"api/#TransitionIndicators.kendalltau","page":"API","title":"TransitionIndicators.kendalltau","text":"kendalltau(x::AbstractVector)\n\nCompute the kendall-τ correlation coefficient of the time series x.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionIndicators.spearman","page":"API","title":"TransitionIndicators.spearman","text":"spearman(x::AbstractVector)\n\nCompute the spearman correlation coefficient of the time series x.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionIndicators.RidgeRegressionSlope","page":"API","title":"TransitionIndicators.RidgeRegressionSlope","text":"RidgeRegressionSlope(; lambda = 0.0)\n\nReturn a PrecomputableFunction containing all the necessary fields to generate a PrecomputedRidgeRegressionSlope. The latter can be initialized by precompute:\n\nrr = precompute( RidgeRegressionSlope() )\n\nKeyword arguments:\n\nlambda: a regularization constant, usually between 0 and 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionIndicators.PrecomputedRidgeRegressionSlope","page":"API","title":"TransitionIndicators.PrecomputedRidgeRegressionSlope","text":"PrecomputedRidgeRegressionSlope(x::AbstractVector)\n\nReturn the slope of the ridge regression of x.\n\n\n\n\n\n","category":"type"},{"location":"api/#Surrogates","page":"API","title":"Surrogates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"For the surrogate generation, you can use any subtype of Surrogate defined in Timeseriessurrogates.jl.","category":"page"},{"location":"api/#Sliding-windows","page":"API","title":"Sliding windows","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"WindowViewer\nwindowmap\nwindowmap!","category":"page"},{"location":"api/#TransitionIndicators.WindowViewer","page":"API","title":"TransitionIndicators.WindowViewer","text":"WindowViewer(x; width, stride)\n\nInitialize an iterator that generates views over the given timeseries x based on a window with a given width, incrementing the window views with the given stride. You can use this directly with map, such as map(std, WindowViewer(x, ...)) would give you the moving-window-timeseries of the std of x.\n\nIf not given, the keywords width, stride are taken as default_window_width(x) and 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionIndicators.windowmap","page":"API","title":"TransitionIndicators.windowmap","text":"windowmap(f::Function, x::AbstractVector; kwargs...) → mapped_f\n\nA shortcut for first generating a wv = WindowViewer(x; kwargs...) and then applying mapped_f = map(f, wv). If x is accompanied by a time vector t, you probably also want to call this function with t instead of x and with one of mean, midpoint, midvalue as f to obtain a time vector for the mapped_f output.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionIndicators.windowmap!","page":"API","title":"TransitionIndicators.windowmap!","text":"windowmap!(f::Function, out, x::AbstractVector; kwargs...)\n\nSame as windowmap, but writes the output in-place in out.\n\n\n\n\n\n","category":"function"},{"location":"#TransitionIndicators.jl","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"","category":"section"},{"location":"","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"(Image: TransitionIndicators.jl)","category":"page"},{"location":"","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"TransitionIndicators","category":"page"},{"location":"#TransitionIndicators","page":"TransitionIndicators.jl","title":"TransitionIndicators","text":"TransitionIndicators.jl\n\n(Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that can estimate indicators of transitions (from one dynamic regime or stable state to another) in timeseries. Also bundles the indicators with significance testing via surrogate analysis using TimeseriesSurrogates.jl. Alternative names for this package could have been: Early Warning Signals / Resilience Indicators / Regime-Shift Identifiers / Change-Point Detectors, or however else you want to call them!\n\nThis package is currently under active development and not yet registered in the Julia general registry. To install it, first go into package-manager mode in the Julia REPL (press ]) and then run\n\nadd https://github.com/JuliaDynamics/TransitionIndicators.jl\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"info: Star us on GitHub!\nIf you have found this package useful, please consider starring it on GitHub. This gives us an accurate lower bound of the (satisfied) user count.","category":"page"},{"location":"#content","page":"TransitionIndicators.jl","title":"Content","text":"","category":"section"},{"location":"","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"Multi-stable systems can display abrupt transitions between two stability regimes. To predict such transitions in real-world systems solely based on data, mathematical tools have been developed in the last decades. Numerous terminologies have been used for them, such as early warning signals, resilience indicators, regime-shift identifiers, change-point detection and transition indicators. TransitionIndicators.jl sticks to the latter terminology and provides an interface that:","category":"page"},{"location":"","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"Allows a fast computation of common transition indicators with a couple of lines, as demonstrated in the example section.\nMakes the surrogate analysis to test for significance under the hub.\nCan be easily extended by any user without touching the source code.\nReduces the programming overhead for any researcher willing to benchmark new methods.\nEases the reproducibility thanks to a clear syntax, a simple installation and RNG-seeded surrogate generation.\nIncreases trustworthiness thanks to a large test suite.","category":"page"},{"location":"","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"info: Similar projects\nAn R toolbox and a Python library already exist. However, we believe that they are difficult to extend for the user. Furthermore, they do not offer a native performant code, as here allowed by the use of Julia.","category":"page"},{"location":"#approaches","page":"TransitionIndicators.jl","title":"Approaches","text":"","category":"section"},{"location":"","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"Over the last decades, research on transition indicators has largely focused on Critical Slowing Down (CSD). CSD is observed when a system approaches a Hopf, a transcritical or a fold bifurcation and consists in a resilience loss of the system. For instance this can be diagnosed by an increase of the variance and the AR1-regression coefficient, as demonstrated in the example section. However, we emphasize that this is one out of many possible approaches for obtaining transition indicators. Recent work has explored new approaches relying on nonlinear dynamics or machine learning. TransitionIndicators.jl is designed to allow these cutting-edge methods and foster the development of new ones.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#workflow","page":"Tutorial","title":"Workflow","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Computing transition indicators consists of the following steps:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Doing any pre-processing of raw data first such as detrending (not part of TransitionIndicators.jl). This yields the input timeseries.\nEstimating the timeseries of an indicator by sliding a window over the input timeseries.\nComputing the changes of the indicator by sliding a window over its timeseries.\nGenerating many surrogates that preserve important statistical properties of the original timeseries.\nPerforming step 2 and 3 for the surrogate timeseries.\nChecking whether the indicator change timeseries of the real timeseries shows a significant feature (trend, jump or anything else) when compared to the surrogate data.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These steps are illustrated one by one in the tutorial below, and then summarized in the convenient API that TransitionIndicators.jl exports.","category":"page"},{"location":"tutorial/#example_stepbystep","page":"Tutorial","title":"Tutorial – Educational","text":"","category":"section"},{"location":"tutorial/#Raw-input-data","page":"Tutorial","title":"Raw input data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let us load data from a bistable nonlinear model subject to noise and to a gradual change of the forcing that leads to a transition. Furthermore, we also load data from a linear model, which is by definition monostable and therefore incapable of transitioning. This is done to control the rate of false positives, a common problem that can emerge when looking for transition indicators. The models are governed by:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dfracmathrmdx_lmathrmdt = - x_l - 1 + f(t) + n(t) \ndfracmathrmdx_nlmathrmdt = - x_nl^3 + x_nl + f(t) + n(t)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"with x_l the state of the linear model, x_nl the state of the bistable model, f the forcing and n the noise. For f=0 they both display an equilibrium point at x=-1. However, the bistable model also displays a further equilibrium point at x=1. Loading (and visualizing with Makie) such prototypical data to test some indicators can be done by simply running:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TransitionIndicators, CairoMakie\n\nt, x_linear, x_nlinear = load_linear_vs_doublewell()\nfig, ax = lines(t, x_nlinear)\nlines!(ax, t, x_linear)\nax.title = \"raw data\"\nfig","category":"page"},{"location":"tutorial/#Preprocessing","page":"Tutorial","title":"Preprocessing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Not part of TransitionIndicators.jl\nAny timeseries pre-processing, such as the de-trending step we do here, is not part of TransitionIndicators.jl and is the responsibility of the researcher.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The nonlinear system clearly displays a transition between two stability regimes. To forecast such transition, we analyze the fluctuations of the timeseries around the tracked attractor. Therefore, a detrending step is needed - here simply obtained by building the difference of the timeseries with lag 1.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"x_l_fluct = diff(x_linear)\nx_nl_fluct = diff(x_nlinear)\ntfluct = t[2:end]\n\nfig, ax = lines(tfluct, x_l_fluct)\nlines!(ax, tfluct, x_nl_fluct .+ 0.05)\nax.title = \"input timeseries\"\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"At this point, x_l_fluct and x_nl_fluct are considered the input timeseries.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Detrending in Julia\nDetrending can be performed in many ways. A wide range of Julia packages exists to perform smoothing such as Loess.jl or DSP.jl. There the detrending step consists of subtracting the smoothed signal from the original one.","category":"page"},{"location":"tutorial/#Indicator-timeseries","page":"Tutorial","title":"Indicator timeseries","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can then compute the values of some \"indicator\" (a Julia function that inputs a timeseries and outputs a number). An indicator should be a quantity that is likely to change if a transition occurs in the timeseries. We compute indicators by applying a sliding window over the input timeseries, determined by the width and the stride with which it is applied. Here we demonstrate this computation with the AR1-regression coefficient (under white-noise assumption), implemented as ar1_whitenoise:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"indicator = ar1_whitenoise\nindicator_window = (width = 400, stride = 1)\n\n# By mapping `last::Function` over a windowviewer of the time vector, we obtain the last time step of each window.\n# This therefore only uses information from `k-width` to `k` at time step `k`.\n# Alternatives: `first::Function`, `midpoint:::Function`.\nt_indicator = windowmap(last, tfluct; indicator_window...)\nindicator_l = windowmap(indicator, x_l_fluct; indicator_window...)\nindicator_nl = windowmap(indicator, x_nl_fluct; indicator_window...)\n\nfig, ax = lines(t_indicator, indicator_l)\nlines!(ax, t_indicator, indicator_nl)\nax.title = \"indicator timeseries\"\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The lines plotted above are the indicator timeseries.","category":"page"},{"location":"tutorial/#Change-metric-timeseries","page":"Tutorial","title":"Change metric timeseries","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"From here, we process the indicator timeseries to quantify changes in it. This step is in essence the same as before: we apply some function over a sliding window of the indicator timeseries. We call this new timeseries the change metric timeseries. In the example here, the change metric we will employ will be the slope (over a sliding window), calculated via means of a RidgeRegressionSlope:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"change_window = (width = 30, stride = 1)\nridgereg = RidgeRegressionSlope(lambda = 0.0)\nprecompridgereg = precompute(ridgereg, t[1:change_window.width])\n\nt_change = windowmap(last, t_indicator; change_window...)\nchange_l = windowmap(precompridgereg, indicator_l; change_window...)\nchange_nl = windowmap(precompridgereg, indicator_nl; change_window...)\n\nfig, ax = lines(t_change, change_l)\nlines!(ax, t_change, change_nl)\nax.title = \"change metric timeseries\"\nfig","category":"page"},{"location":"tutorial/#Timeseries-surrogates","page":"Tutorial","title":"Timeseries surrogates","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected from Critical Slowing Down, an increase of the AR1-regression coefficient can be observed. Although eyeballing the timeseries might already be suggestive, we want a rigorous framework for testing for significance.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In TransitionsIdentifiers.jl we perform significance testing using the method of timeseries surrogates and the TimeseriesSurrogates.jl Julia package. This has the added benefits of flexibility in choosing the surrogate generation method, reproducibility, and automation. Note that TimeseriesSurrogates is re-exported by TransitionIndicators, so that you don't have to using both of them.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To illustrate the surrogate, we compare the change metric computed from the bistable timeseries what that computed from a surrogate of the same timeseries.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Generate Fourier random-phase surrogates\nusing Random: Xoshiro\ns = surrogate(x_nl_fluct, RandomFourier(), Xoshiro(123))\nfig, ax = lines(tfluct, x_nl_fluct; color = Cycled(2))\nlines!(ax, tfluct, s .- 0.05; color = Cycled(3))\nax.title = \"real signal vs. surrogate(s)\"\n\n# compute and plot indicator and change metric\nindicator_s = windowmap(indicator, s; indicator_window...)\nchange_s = windowmap(precompridgereg, indicator_s; change_window...)\n\nax, = lines(fig[1,2], t_change, change_nl; color = Cycled(2), label = \"nonlin\")\nlines!(ax, t_change, change_s; color = Cycled(3), label = \"surrogate\")\naxislegend()\nax.title = \"change metric\"\n\nfig","category":"page"},{"location":"tutorial/#Quantifying-significance","page":"Tutorial","title":"Quantifying significance","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To quantify the significance of the values of the change metric timeseries we perform a standard surrogate test by computing the p-value w.r.t. the change metrics of thousands of surrogates of the input timeseries. A low p-value (typically p<0.05) is commonly considered as significant. To visualize significant trends, we plot the p-value vs. time:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"n_surrogates = 1_000\nfig = Figure()\naxl = Axis(fig[1,1]; title = \"linear\")\naxnl = Axis(fig[1,2]; title = \"nonlinear\")\naxsigl = Axis(fig[2,1])\naxsignl = Axis(fig[2,2])\n\nfor (j, ax, axsig, x) in zip(1:2, (axl, axnl), (axsigl, axsignl), (x_l_fluct, x_nl_fluct))\n\n    orig_change = j == 1 ? change_l : change_nl\n    sgen = surrogenerator(x, RandomFourier(), Xoshiro(123))\n    pval = zeros(length(change_s))\n\n    # Collect all surrogate change metrics\n    for i in 1:n_surrogates\n        s = sgen()\n        indicator_s = windowmap(indicator, s; indicator_window...)\n        change_s = windowmap(precompridgereg, indicator_s; change_window...)\n        pval += orig_change .< change_s\n    end\n\n    pval ./= n_surrogates\n    lines!(ax, t_change, orig_change; color = Cycled(j))\n    lines!(axsig, t_change, pval; color = Cycled(j+2))\nend\n\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected, the data generated by the nonlinear model displays a significant increase of the AR1-regression coefficient before the transition, which is manifested by a low p-value. In contrast, the data generated by the linear model does not show anything similar.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Performing the step-by-step analysis of transition indicators is possible and might be preferred for users wanting high flexibility. However, this results in a substantial amount of code. We therefore provide convenience functions that wrap this analysis, as shown in the next section.","category":"page"},{"location":"tutorial/#example_fastforward","page":"Tutorial","title":"Tutorial – TransitionIndicators.jl","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TransitionIndicators.jl wraps this typical workflow into a simple, extendable, and modular API that researchers can use with little effort. In addition, it allows performing the same analysis for several indicators / change metrics in one go.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The interface is simple, and directly parallelizes the Workflow as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Create an instance of IndicatorsConfig, that dictates which indicators will be used, and over what sliding window.\nCreate an instance of SignificanceConfig, that dictates what change metrics, surrogate types, and sliding window will be used to quantify a significant change of the indicators.\nAlong with the input timeseries x these three are plugged into indicators_analysis.\nThe output, which is an IndicatorsResults, can be used to visualize the results.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The following blocks apply this process, and visualize it, for the examples we used in the educational part of the tutorial. First we load, and do the necessary pre-processing, to get input data:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TransitionIndicators, CairoMakie\n\nt, x_linear, x_nlinear = load_linear_vs_doublewell()\n\nx_nl_fluct = diff(x_nlinear)\ntfluct = t[2:end]\n\nfig, ax = lines(tfluct, x_nl_fluct)\nax.title = \"input timeseries\"\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then we decide what indicators and change metrics to use and run the analysis.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# These indicators are suitable for Critical Slowing Down\nindicators = [var, ar1_whitenoise]\nindconfig = IndicatorsConfig(tfluct, last, indicators; width = 400)\n\n\n# use the ridge regression slope for both indicators\nchange_metrics = [RidgeRegressionSlope()]\nsigconfig = SignificanceConfig(indconfig, last, change_metrics;\n    width = 30, n_surrogates = 1000)\n\n# perform the full analysis\nresults = indicators_analysis(tfluct, x_nl_fluct, indconfig, sigconfig)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"That's it, just a couple of lines! To get insight on the results, we plot the obtained p-values vs. the original time series:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fig, ax = lines(tfluct, x_nl_fluct; color = Cycled(2), label = \"input\")\naxpval, = lines(fig[2,1], sigconfig.t_change, results.pval[:, 1]; color = Cycled(3), label = \"p-value of var\")\nlines!(axpval, sigconfig.t_change, results.pval[:, 2]; color = Cycled(4), label = \"p-value of ar1\")\nxlims!(ax, (0, 50))\nxlims!(axpval, (0, 50))\naxislegend(axpval)\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Thresholding the p-value results in a loss of information and it is therefore preferable to be avoided. For automation purposes it might however be unavoidable. Here we show an example where we consider that both the variance and the AR1-regression coefficient need to show a p-value below 0.05 for a transition to be indicated in a binary sense:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"threshold = 0.05\nsignif_idxs = vec(count(results.pval .< threshold, dims = 2) .>= 2)\ntflags = results.t_change[signif_idxs]\nvlines!(ax, tflags; label = \"flags\", color = Cycled(3), linestyle = :dash)\naxislegend(ax)\nfig","category":"page"}]
}
