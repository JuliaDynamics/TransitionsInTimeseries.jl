var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Load-data","page":"API","title":"Load data","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"load_linear_vs_doublewell()","category":"page"},{"location":"api/#TransitionIndicators.load_linear_vs_doublewell-Tuple{}","page":"API","title":"TransitionIndicators.load_linear_vs_doublewell","text":"load_linear_vs_doublewell()\n\nLoad prototypical data from a linear and a double-well model to test some indicators.\n\n\n\n\n\n","category":"method"},{"location":"api/#Indicators-analysis","page":"API","title":"Indicators analysis","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"IndicatorsConfig\nSignificanceConfig\nindicators_analysis","category":"page"},{"location":"api/#TransitionIndicators.IndicatorsConfig","page":"API","title":"TransitionIndicators.IndicatorsConfig","text":"IndicatorsConfig(indicators...; window_kwargs...)\n\nA configuration for computing indicators from timeseries. Indicators are standard Julia functions that input an AbstractVector and output a real number. Any number of indicators can be given. Indicators typically used in the literature are listed in the documentation section Indicators.\n\nKeywords are propagated into WindowViewer to create a sliding window for estimating the indicators.\n\nAlong with SignificanceConfig it is given to indicators_analysis.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionIndicators.SignificanceConfig","page":"API","title":"TransitionIndicators.SignificanceConfig","text":"SignificanceConfig(change_metrics...; kwargs...)\n\nA configuration for estimating a significant change of indicators computed from timeseries. Along with IndicatorsConfig it is given to indicators_analysis.\n\nchange_metrics can be a single Julia function, in which case the same metric is applied over all indicators in IndicatorsConfig. change_metrics can also be many functions, each one for each indicator.\n\nKeyword arguments\n\nn_surrogates::Int = 10_000: how many surrogates to create.\nsurrogate_method::S = RandomFourier(): what method to use to create the surrogates. Any Surrogate subtype from TimeseriesSurrogates.jl is valid.\nrng::AbstractRNG = Random.default_rng()`: a random number generator for the surrogates. See the Julia manual for more.\nwv_indicator_width::Int = 100,\nwv_indicator_stride::Int = 5,\nwidth, stride = 20, 1: width and stride given to the WindowViewer of the indicator timeseries. Notice that here the default values are different.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionIndicators.indicators_analysis","page":"API","title":"TransitionIndicators.indicators_analysis","text":"indicators_analysis(x, indicators::IndicatorsConfig, significance::SignificanceConfig)\n\nPerform an analysis of transition indicators for input timeseries x by specifying which indicators to use and with what sliding window (IndicatorsConfig), as well as how to measure significant changes in the indicators (SignificanceConfig).\n\nReturn the output as IndicatorsResults.\n\nThis function performs the analysis described in the documentation Example sections. It computes various indicators over sliding windows of x, and then computes change metrics of over sliding windows of the indicators. In parallel it does exactly the same computations for surrogates of x. The returned output contains all these computed timeseries and can be given to indicators_significance.\n\n\n\n\n\n","category":"function"},{"location":"api/#Indicators-significance","page":"API","title":"Indicators significance","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"indicators_significance\nSignificanceTest\nQuantile\nSigma\nsignificant","category":"page"},{"location":"api/#TransitionIndicators.indicators_significance","page":"API","title":"TransitionIndicators.indicators_significance","text":"indicators_significance(res::IndicatorsResults, q::SignificanceTest) → out\n\nGiven the output of indicators_analysis, estimate when the computed indicators have a statistically significant change, with \"significant\" defined by q, which is a subtype of SignificanceTest.\n\nThe output is returned as an n×m matrix with n the length of the time vector of the change metric timeseries, and m the number of change metrics (which is the same as the number of indicators). The values of the matrix are Booleans (true for significant).\n\nYou can use prod(out; dim = 2) for logical & product across indicators.\n\n\n\n\n\n","category":"function"},{"location":"api/#indicator_functions","page":"API","title":"Indicators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ar1_whitenoise\nStatistics.mean(::Any)\nStatistics.var(::AbstractArray)\nStatsBase.skewness\nStatsBase.kurtosis","category":"page"},{"location":"api/#TransitionIndicators.ar1_whitenoise","page":"API","title":"TransitionIndicators.ar1_whitenoise","text":"ar1_whitenoise(x) → ̂θ\n\nEstimate the AR1 regression coefficient θ of a vector time series x. Computation based on the analytic solution of the least-square parameter estimation:\n\n    hattheta = dfracsum_i=2^n x_i  x_i-1sum_i=2^n x_i-1^2\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics.mean-Tuple{Any}","page":"API","title":"Statistics.mean","text":"mean(itr)\n\nCompute the mean of all elements in a collection.\n\nnote: Note\nIf itr contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the mean of non-missing values.\n\nExamples\n\njulia> using Statistics\n\njulia> mean(1:20)\n10.5\n\njulia> mean([1, missing, 3])\nmissing\n\njulia> mean(skipmissing([1, missing, 3]))\n2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.var-Tuple{AbstractArray}","page":"API","title":"Statistics.var","text":"var(itr; corrected::Bool=true, mean=nothing[, dims])\n\nCompute the sample variance of collection itr.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of itr is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating sum((itr .- mean(itr)).^2) / (length(itr) - 1)). If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n is the number of elements in itr.\n\nIf itr is an AbstractArray, dims can be provided to compute the variance over dimensions.\n\nA pre-computed mean may be provided. When dims is specified, mean must be an array with the same shape as mean(itr, dims=dims) (additional trailing singleton dimensions are allowed).\n\nnote: Note\nIf array contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the variance of non-missing values.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsBase.skewness","page":"API","title":"StatsBase.skewness","text":"skewness(v, [wv::AbstractWeights], m=mean(v))\n\nCompute the standardized skewness of a real-valued array v, optionally specifying a weighting vector wv and a center m.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsBase.kurtosis","page":"API","title":"StatsBase.kurtosis","text":"kurtosis(v, [wv::AbstractWeights], m=mean(v))\n\nCompute the excess kurtosis of a real-valued array v, optionally specifying a weighting vector wv and a center m.\n\n\n\n\n\n","category":"function"},{"location":"api/#Change-metrics","page":"API","title":"Change metrics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"RidgeRegression\nkendalltau\nspearman","category":"page"},{"location":"api/#TransitionIndicators.RidgeRegression","page":"API","title":"TransitionIndicators.RidgeRegression","text":"RidgeRegression(t, width; lambda = 0.0) → rr\n\nInitialize a ridge regression for a time vector t, a sliding-window width and an optional regularizeation term lambda. The output rr can then be used as a function to perform the regression and extract the slope! If lambda = 0, linear regression is recovered (default case). For more information, visit: https://en.wikipedia.org/wiki/Ridge_regression.\n\nExamples\n\njulia> t = 0.0:1.0:100;\njulia> x = 2.3 .* t .+ 1.2;\njulia> rr = RidgeRegression(t);\njulia> rr(x)\n2.299999999999999\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionIndicators.kendalltau","page":"API","title":"TransitionIndicators.kendalltau","text":"kendalltau(x)\n\nCompute the kendall-τ correlation coefficient of the time series x.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionIndicators.spearman","page":"API","title":"TransitionIndicators.spearman","text":"spearman(x)\n\nCompute the spearman correlation coefficient of the time series x.\n\n\n\n\n\n","category":"function"},{"location":"api/#Surrogates","page":"API","title":"Surrogates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"For the surrogate generation, you can use any subtype of Surrogate defined in Timeseriessurrogates.jl.","category":"page"},{"location":"api/#Significance-metrics","page":"API","title":"Significance metrics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"threshold_indicators\nmeasure_significance\nconfidence_interval\nnormalized_percentile","category":"page"},{"location":"api/#Sliding-windows","page":"API","title":"Sliding windows","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"WindowViewer\nwindowmap\nwindowmap!","category":"page"},{"location":"api/#TransitionIndicators.WindowViewer","page":"API","title":"TransitionIndicators.WindowViewer","text":"WindowViewer(x; width, stride)\n\nInitialize an iterator that generates views over the given timeseries x based on a window with a given width, incrementing the window views with the given stride. You can use this directly with map, such as map(std, WindowViewer(x, ...)) would give you the moving-window-timeseries of the std of x.\n\nIf not given, the keywords width, stride as taken as length(x)÷100 and 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionIndicators.windowmap","page":"API","title":"TransitionIndicators.windowmap","text":"windowmap(f::Function, x::AbstractVector; kwargs...) → mapped_f\n\nA shortcut for first generating a wv = WindowViewer(x; kwargs...) and then applying mapped_f = map(f, wv). If x is accompanied by a time vector t, you probably also want to call this function with t instead of x and with one of mean, midpoint, midvalue as f to obtain a time vector for the mapped_f output.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionIndicators.windowmap!","page":"API","title":"TransitionIndicators.windowmap!","text":"windowmap!(f::Function, out, x::AbstractVector; kwargs...)\n\nSame as windowmap, but writes the output in-place in out.\n\n\n\n\n\n","category":"function"},{"location":"#TransitionIndicators.jl","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"","category":"section"},{"location":"","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"(Image: TransitionIndicators.jl)","category":"page"},{"location":"","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"TransitionIndicators","category":"page"},{"location":"#TransitionIndicators","page":"TransitionIndicators.jl","title":"TransitionIndicators","text":"TransitionIndicators.jl\n\n(Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that can estimate indicators of transitions (from one dynamic regime or stable state to another) in timeseries. Also bundles the indicators with significance testing via surrogate analysis using TimeseriesSurrogates.jl. Alternative names for this package could have been: Early Warning Signals / Resilience Indicators / Regime-Shift Identifiers / Change-Point Detectors, or however else you want to call them!\n\nTo install it, run import Pkg; Pkg.add(\"TransitionIndicators\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"info: Star us on GitHub!\nIf you have found this package useful, please consider starring it on GitHub. This gives us an accurate lower bound of the (satisfied) user count.","category":"page"},{"location":"#content","page":"TransitionIndicators.jl","title":"Content","text":"","category":"section"},{"location":"","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"Multi-stable systems can display abrupt transitions between two stability regimes. To predict such transitions in real-world systems solely based on data, mathematical tools have been developed in the last decades. Numerous terminologies have been used for them, such as early warning signals, resilience indicators, regime-shift identifiers, change-point detection and transition indicators. TransitionIndicators.jl sticks to the latter terminology and provides an interface that:","category":"page"},{"location":"","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"Allows a fast computation of common transition indicators with a couple of lines, as demonstrated in the example section.\nMakes the surrogate analysis to test for significance under the hub.\nCan be easily extended by any user without touching the source code.\nReduces the programming overhead for any researcher willing to benchmark new methods.\nEases the reproducibility thanks to a clear syntax, a simple installation and RNG-seeded surrogate generation.\nIncreases trustworthiness thanks to a large test suite.","category":"page"},{"location":"","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"info: Similar projects\nAn R toolbox and a Python library already exist. However, we believe that they are difficult to extend for the user. Furthermore, they do not offer a native performant code, as here allowed by the use of Julia.","category":"page"},{"location":"#approaches","page":"TransitionIndicators.jl","title":"Approaches","text":"","category":"section"},{"location":"","page":"TransitionIndicators.jl","title":"TransitionIndicators.jl","text":"Over the last decades, research on transition indicators has largely focused on Critical Slowing Down (CSD). CSD is observed when a system with continuous right-hand side approaches a bifurcation and consists in a resilience loss of the system. For instance this can be diagnosed by an increase of the variance and the AR1-regression coefficient, as demonstrated in the example section. However, we emphasize that this is one out of many possible approaches for obtaining transition indicators. Recent work has explored new approaches relying on nonlinear dynamics or machine learning. TransitionIndicators.jl is designed to allow these cutting-edge methods and foster the development of new ones.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#workflow","page":"Tutorial","title":"Workflow","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Computing transition indicators consists of the following steps:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Doing any pre-processing of raw data first such as detrending (not part of TransitionIndicators.jl). This yields the input timeseries.\nEstimating the timeseries of an indicator by sliding a window over the input timeseries.\nComputing the changes of the indicator by sliding a window over its timeseries.\nGenerating many surrogates that preserve important statistical properties of the original timeseries.\nPerforming step 2 and 3 for the surrogate timeseries.\nChecking whether the indicator change timeseries of the real timeseries shows a significant feature (trend or jump or anything else) when compared to the surrogate data.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These steps are illustrated one by one in the tutorial below, and then summarized in the convenient API that TransitionIndicators.jl exports.","category":"page"},{"location":"tutorial/#example_stepbystep","page":"Tutorial","title":"Tutorial – Educational","text":"","category":"section"},{"location":"tutorial/#Raw-input-data","page":"Tutorial","title":"Raw input data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let us load data from a bistable nonlinear model subject to noise and to a gradual change of the forcing that leads to a transition. Furthermore, we also load data from a linear model, which is by definition monostable and therefore incapable of transitioning. This is done to control the rate of false positives, a common problem that can emerge when looking for transition indicators. The models are governed by:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dfracmathrmdx_lmathrmdt = - x_l - 1 + f(t) + n(t) \ndfracmathrmdx_nlmathrmdt = - x_nl^3 + x_nl + f(t) + n(t)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"with x_l the state of the linear model, x_nl the state of the bistable model, f the forcing and n the noise. For f=0 they both display an equilibrium point at x=-1. However, the bistable model also displays a further equilibrium point at x=1. Loading (and visualizing with Makie) such prototypical data to test some indicators can be done by simply running:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TransitionIndicators\nusing CairoMakie\n\nt, x_linear, x_nlinear = load_linear_vs_doublewell()\nfig, ax = lines(t, x_linear)\nlines!(ax, t, x_nlinear)\nax.title = \"raw data\"\nfig","category":"page"},{"location":"tutorial/#Preprocessing","page":"Tutorial","title":"Preprocessing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Not part of TransitionIndicators.jl\nAny timeseries pre-processing, such as the de-trending step we do here, is not part of TransitionIndicators.jl and is the responsibility of the researcher.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The nonlinear system clearly displays a transition between two stability regimes. To forecast such transition, we analyze the fluctuations of the timeseries around the tracked attractor. Therefore, a detrending step is needed - here simply obtained by building the difference of the timeseries with lag 1.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"x_l_fluct = diff(x_linear)\nx_nl_fluct = diff(x_nlinear)\ntfluct = t[2:end]\n\nfig, ax = lines(tfluct, x_l_fluct)\nlines!(ax, tfluct, x_nl_fluct .+ 0.05)\nax.title = \"input timeseries\"\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"At this point, x_l_fluct and x_nl_fluct are considered the input timeseries.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Detrending in Julia\nDetrending can be performed in many ways. A wide range of Julia packages exists to perform smoothing such as Loess.jl or DSP.jl. There the detrending step consists of subtracting the smoothed signal from the original one.","category":"page"},{"location":"tutorial/#Indicator-timeseries","page":"Tutorial","title":"Indicator timeseries","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can then compute the values of some \"indicator\" (a Julia function that inputs a timeseries and outputs a number). An indicator should be a quantity that is likely to change if a transition occurs in the timeseries. We compute indicators by applying a sliding window over the input timeseries, determined by the width and the stride with which it is applied. Here we demonstrate this computation with the AR1-regression coefficient (under white-noise assumption), implemented as ar1_whitenoise:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"indicator = ar1_whitenoise\nindicator_window = (width = 400, stride = 1)\n\nt_indicator = windowmap(midpoint, tfluct; indicator_window...)\n\nindicator_l = windowmap(indicator, x_l_fluct; indicator_window...)\n\nindicator_nl = windowmap(indicator, x_nl_fluct; indicator_window...)\n\nfig, ax = lines(t_indicator, indicator_l)\nlines!(ax, t_indicator, indicator_nl)\nax.title = \"indicator timeseries\"\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The lines plotted above are the indicator timeseries.","category":"page"},{"location":"tutorial/#Change-metric-timeseries","page":"Tutorial","title":"Change metric timeseries","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"From here, we process the indicator timeseries to quantify changes in it. This step is in essence the same as before: we apply some function over a sliding window of the indicator timeseries. We call this new timeseries the change metric timeseries. In the example here, the change metric we will employ will be the slope (over a sliding window), calculated via means of a ridge regression","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"change_window = (width = 20, stride = 1)\nridgereg = RidgeRegression(t_indicator, change_window.width)\n\nt_change = windowmap(midpoint, t_indicator; change_window...)\nchange_l = windowmap(ridgereg, indicator_l; change_window...)\nchange_nl = windowmap(ridgereg, indicator_nl; change_window...)\n\nfig, ax = lines(t_change, change_l)\nlines!(ax, t_change, change_nl)\nax.title = \"change metric timeseries\"\nfig","category":"page"},{"location":"tutorial/#Timeseries-surrogates","page":"Tutorial","title":"Timeseries surrogates","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected from Critical Slowing Down, an increase of the AR1-regression coefficient can be observed. Although eyeballing the timeseries might already be suggestive, we want a rigorous framework for testing for significance.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In TransitionsIdentifiers.jl we perform significance testing using the method of timeseries surrogates and the TimeseriesSurrogates.jl Julia package. This has the added benefits of flexibility in choosing the surrogate generation method, reproducibility, and automation. Note that TimeseriesSurrogates is re-exported by TransitionIndicators, so that you don't have to using both of them.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To illustrate the surrogate, we compare the change metric computed from the bistable timeseries what that computed from a surrogate of the same timeseries.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Generate Fourier random-phase surrogates\nusing Random: Xoshiro\ns = surrogate(x_nl_fluct, RandomFourier(), Xoshiro(123))\nfig, ax = lines(tfluct, x_nl_fluct; color = Cycled(2))\nlines!(ax, tfluct, s .- 0.05; color = Cycled(3))\nax.title = \"real signal vs. surrogate(s)\"\n\n# compute and plot change metric\nindicator_s = windowmap(indicator, s; indicator_window...)\nchange_s = windowmap(ridgereg, indicator_s; change_window...)\n\nax, = lines(fig[1,2], t_change, change_nl; color = Cycled(2), label = \"nonlin\")\nlines!(ax, t_change, change_s; color = Cycled(3), label = \"surrogate\")\naxislegend()\nax.title = \"change metric\"\n\nfig","category":"page"},{"location":"tutorial/#Quantifying-significance","page":"Tutorial","title":"Quantifying significance","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To quantify the significance of the values of the change metric timeseries we perform a standard surrogate test. We calculate the change metric for thousands of surrogates of the input timeseries, and then detect the points in time where the change metric timeseries exceeds a threshold (such as the 95-quantile) of the change metrics of the surrogates.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To visualize significant trends, we plot the bands giving the (-2  sigma 2  sigma) and (-3  sigma 3  sigma) intervals of the surrogate values, with sigma the standard-deviation of indicator slope across the surrogate timeseries:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"n_surrogates = 1_000\nfig = Figure()\naxl = Axis(fig[1,1]; title = \"linear\")\naxnl = Axis(fig[1,2]; title = \"nonlinear\")\n\nfor (j, ax, x) in zip(1:2, (axl, axnl), (x_l_fluct, x_nl_fluct))\n\n    sgen = surrogenerator(x, RandomFourier(), Xoshiro(123))\n    change_s_distr =  zeros(n_surrogates, length(change_s))\n\n    # Collect all surrogate change metrics\n    for i in 1:n_surrogates\n        s = sgen()\n        indicator_s = windowmap(indicator, s; indicator_window...)\n        change_s = windowmap(ridgereg, indicator_s; change_window...)\n        change_s_distr[i, :] .= change_s\n    end\n\n    mu = vec(mean(change_s_distr, dims = 1))\n    sigma = vec(std(change_s_distr, dims = 1))\n\n    # Plot (real signal) change metric and various confidence intervals\n    orig_change = j == 1 ? change_l : change_nl\n    lines!(ax, t_change, orig_change; color = Cycled(j))\n    band!(ax, t_change, mu .- 2 .* sigma, mu .+ 2 .* sigma, color = (:red, 0.2) )\n    band!(ax, t_change, mu .- 3 .* sigma, mu .+ 3 .* sigma, color = (:red, 0.1) )\nend\n\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected, the data generated by the nonlinear model displays a significant increase of the AR1-regression coefficient before the transition, while the data generated by the linear model does not.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Performing the step-by-step analysis of transition indicators is possible and might be preferred for users wanting high flexibility. However, this results in a substantial amount of code. We therefore provide convenience functions that wrap this analysis, as shown in the next section.","category":"page"},{"location":"tutorial/#example_fastforward","page":"Tutorial","title":"Tutorial – TransitionIndicators.jl","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TransitionIndicators.jl wraps this typical workflow into a simple, extendable, and modular API that researchers can use with little effort. In addition, it allows performing the same analysis for several different indicators / change metrics in one go.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The interface is simple, and directly parallelizes the Workflow as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Create an instance of IndicatorsConfig, that dictates which indicators will be used, and over what sliding window.\nCreate an instance of SignificanceConfig, that dictates what change metrics, surrogate types, and sliding window will be used to quantify a significant change of the indicators.\nAlong with the input timeseries x these three are plugged into indicators_analysis.\nThe output, which is an IndicatorsResults, can be used to visualize the results, or given to indicators_significance to provide flags of the timepoints where there is a significant change of each indicator.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The following blocks apply this process, and visualize it, for the examples we used in the educational part of the tutorial.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First we load, and do the necessary pre-processing, to get input data","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TransitionIndicators, CairoMakie\n\nt, x_linear, x_nlinear = load_linear_vs_doublewell()\n\nx_nl_fluct = diff(x_nlinear)\ntfluct = t[2:end]\n\nfig, ax = lines(tfluct, x_nl_fluct)\nax.title = \"input timeseries\"\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then we decide what indicators and change metrices to use","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# these indicators are suitable for Critical Slowing Down\nindicators = [var, ar1_whitenoise]\nind_conf = IndicatorsConfig(indicators; width = 400)\n\n# use spearman correlation for both indicators\nchange_metric = spearman\nsig_conf = SignificanceConfig(change_metric; width = 20, n_surrogates = 1000)\n\n# perform the full analysis\nresult = indicators_analysis(x_nl_fluct, ind_conf, sig_conf)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And lastly, obtain some flags for when there is a significant indicator change","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sig = indicators_significance(result, 0.99)\n\n# Plot the original timeseries\nfig, ax = lines(tfluct, x_nl_fluct; label = \"input\")\n# Scatter the significance of each indicator\nfor i in size(sig, 2)\n    signif_idxs = findall(sig[:, i])\n    isempty(signif_idxs) && continue\n    # get timepoints in real time\n    tflags = tfluct[result.t_change[signif_idxs]]\n    vlines!(ax, tflags; label = \"indicator $(indicators[i])\", color = Cycled(1+i))\nend\naxislegend()\nfig","category":"page"}]
}
