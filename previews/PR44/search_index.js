var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Main-analysis-functions","page":"API","title":"Main analysis functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"WindowedIndicatorConfig\ntransition_metrics\nWindowedIndicatorResults","category":"page"},{"location":"api/#TransitionsInTimeseries.WindowedIndicatorConfig","page":"API","title":"TransitionsInTimeseries.WindowedIndicatorConfig","text":"WindowedIndicatorConfig(indicators, change_metrics; kwargs...) → config\n\nA configuration struct for TransitionsInTimeseries.jl that collects what indicators and corresponding metrics to use in the transitions_analysis.\n\nindicators is a tuple of indicators (or a single indicator). change_metrics is also a tuple or a single function. If a single function, the same change metric is used for all provided indicators. This way the analysis can be efficiently repeated for many indicators and/or change metrics.\n\nBoth indicators and change metrics are generic Julia functions that input an x::AbstractVector and output an s::Real. Any appropriate function may be given and see making custom indicators/change metrics in the documentation for more information.\n\nKeyword arguments\n\nwidth_ind::Int=100, stride_ind::Int=1: width and stride given to WindowViewer to compute the indicator from the input timeseries.\nwidth_cha::Int=50, stride_cha::Int=1: width and stride given to WindowViewer to compute the change metric timeseries from the indicator timeseries.\nwhichtime = midpoint: The time vector corresponding to the indicators / change metric timeseries is obtained from t in transitions_analysis using the keyword whichtime. Options include:\nlast: use the last timepoint of each window\nmidpoint: use the mid timepoint of each time window\nfirst: use first timepoint of each window\nIn fact, the indicators time vector is computed simply via\nt_indicator = windowmap(whichtime, t; width_ind, stride_ind)\nt_change = windowmap(whichtime, t_indicator; width_cha, stride_cha)\nso any other function of the time window may be given to extract the time point itself, such as mean or median.\nT = Float64: Element type of input timeseries to initialize some computations.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.transition_metrics","page":"API","title":"TransitionsInTimeseries.transition_metrics","text":"transition_metrics(config::WindowedIndicatorConfig, x [,t]) → output\n\nEstimate possible transitions for input timeseries x using a sliding window approach as described by config:\n\nEstimate the timeseries of an indicator by sliding a window over the input timeseries.\nEstimate changes of an indicator by sliding a window of the change metric over the indicator timeseries.\n\nIf t (the time vector of x), is not provided, it is assumed t = eachindex(x).\n\nReturn the output as WindowedIndicatorResults which can be given to estimate_significance! to deduce which possible transitions are statistically significant using a variety of significance tests.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.WindowedIndicatorResults","page":"API","title":"TransitionsInTimeseries.WindowedIndicatorResults","text":"WindowedIndicatorResults\n\nA struct containing the output of transition_metrics used with WindowedIndicatorConfig. It can be used for further analysis, visualization, or given to estimate_significance!.\n\nIt has the following fields that the user may access\n\nx: the input timeseries.\nt: the time vector of the input timeseries.\nx_indicator, the indicator timeseries (matrix with each column one indicator).\nt_indicator, the time vector of the indicator timeseries.\nx_change, the change metric timeseries (matrix with each column one change metric).\nt_change, the time vector of the change metric timeseries.\nwim::WindowedIndicatorConfig, used for the analysis.\n\n\n\n\n\n","category":"type"},{"location":"api/#Significance-testing","page":"API","title":"Significance testing","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"estimate_significance\nSignificanceConfig\nSurrogatesConfig\nTransitionsSignificance\nSurrogatesSignificance\nQuantileSignificance","category":"page"},{"location":"api/#TransitionsInTimeseries.estimate_significance","page":"API","title":"TransitionsInTimeseries.estimate_significance","text":"estimate_significance(sigconfig::SignificanceConfig, res::WindowedIndicatorResults)\n\nEstimate the significance of the transition metrics stored in res by using the method described by sigconfig and return the results in TransitionsSignificance.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.SignificanceConfig","page":"API","title":"TransitionsInTimeseries.SignificanceConfig","text":"SignificanceConfig\n\nSupertype used to test for significance in estimate_significance. Valid subtypes are:\n\nSurrogatesConfig.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.SurrogatesConfig","page":"API","title":"TransitionsInTimeseries.SurrogatesConfig","text":"SurrogatesConfig <: SignificanceConfig\nSurrogatesConfig(; surrogate = RandomFourier(), n = 1_000, tail = :both, rng)\n\nA configuration struct for significance testing estimate_significance using timeseries surrogates.\n\nKeyword arguments\n\nsurromethod = RandomFourier(): method to generate surrogates\nn = 1_000: how many surrogates to generate\nrng = Random.default_rng(): random number generator for the surrogates\np = 0.05: threshold for significance of the p-value\ntail = :both: tail type used, see below\ndetrend_surro = false: Boolean specifying whether the surrogates are to be\n\ndetrended by a linear regression. This is sometimes performed in the literature  but seldomly impacts the results in a significant way, since the surrogates of  the residual should already be largely free of trend.\n\nDescription\n\nWhen used with WindowedIndicatorResults, significance is estimated as follows: n surrogates from the input timeseries are generated using surromethod, which is any Surrogate subtype provided by TimeseriesSurrogates.jl. For each surrogate, the indicator and then change metric timeseries is extracted. The values of the surrogate change metrics form a distribution of values (one at each time point). The value of the original change metric is compared to that of the surrogate distribution and a p-value is extracted according to the specified tail. The p-value is compared with p to claim significance, which results in flags. These results are then stored in SurrogatesSignificance.\n\nThe p-value is simply the proportion of surrogate change metric values that exceed (for tail = :right) or subseed (tail = :left) the original change metric at each given time point. Use tail = :left if the surrogate data are expected to have  higher change metric, discriminatory statistic values. This is the case for statistics  that quantify entropy. For statistics that quantify autocorrelation, use tail = :right instead. For anything else, use the default tail = :both. An iterable of tail values can also be given, in which case a specific tail is used for each change metric in WindowedIndicatorResults.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.TransitionsSignificance","page":"API","title":"TransitionsInTimeseries.TransitionsSignificance","text":"TransitionsSignificance\n\nSupertype used to store the results of estimate_significance based on a SignificanceConfig. Valid subtypes are:\n\nSurrogatesSignificance.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.SurrogatesSignificance","page":"API","title":"TransitionsInTimeseries.SurrogatesSignificance","text":"SurrogatesSignificance\n\nA struct containing the results of estimate_significance based on a SurrogatesConfig, i.e. the p-values and their associated flags. The former gives a continuous value between 0 and 1, with 0 denoting an extremely unlikely and therefore probably significant behavior of the original time series compared to the ensemble of surrogates. The latter is a Boolean matrix which contains true wherever the p-values are below the threshold defined in SurrogatesConfig. Both signif.p_values and signif.flags have the same size as res.x_change, with signif::SurrogatesSignificance and res::WindowedIndicatorResults.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.QuantileSignificance","page":"API","title":"TransitionsInTimeseries.QuantileSignificance","text":"QuantileSignificance(; p = 0.95, tail = :right) <: TransitionsSignificance\n\nA configuration struct for significance testing significant_transitions. When used with WindowedIndicatorResults, significance is estimated as by comparing the value of each change metric with its p-quantile. Values that exceed the p-quantile (if tail = :right) or subseed the 1-p-quantile (if tail = :left) are deemed significant. If tail = :both then either condition is checked.\n\n\n\n\n\n","category":"type"},{"location":"api/#indicators","page":"API","title":"Indicators","text":"","category":"section"},{"location":"api/#Value-distribution","page":"API","title":"Value distribution","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Statistics.mean(::Any)\nStatsBase.skewness\nStatsBase.kurtosis","category":"page"},{"location":"api/#Statistics.mean-Tuple{Any}","page":"API","title":"Statistics.mean","text":"mean(itr)\n\nCompute the mean of all elements in a collection.\n\nnote: Note\nIf itr contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the mean of non-missing values.\n\nExamples\n\njulia> using Statistics\n\njulia> mean(1:20)\n10.5\n\njulia> mean([1, missing, 3])\nmissing\n\njulia> mean(skipmissing([1, missing, 3]))\n2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsBase.skewness","page":"API","title":"StatsBase.skewness","text":"skewness(v, [wv::AbstractWeights], m=mean(v))\n\nCompute the standardized skewness of a real-valued array v, optionally specifying a weighting vector wv and a center m.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsBase.kurtosis","page":"API","title":"StatsBase.kurtosis","text":"kurtosis(v, [wv::AbstractWeights], m=mean(v))\n\nCompute the excess kurtosis of a real-valued array v, optionally specifying a weighting vector wv and a center m.\n\n\n\n\n\n","category":"function"},{"location":"api/#Critical-Slowing-Down","page":"API","title":"Critical Slowing Down","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Statistics.var(::AbstractArray)\nar1_whitenoise","category":"page"},{"location":"api/#Statistics.var-Tuple{AbstractArray}","page":"API","title":"Statistics.var","text":"var(itr; corrected::Bool=true, mean=nothing[, dims])\n\nCompute the sample variance of collection itr.\n\nThe algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of itr is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating sum((itr .- mean(itr)).^2) / (length(itr) - 1). If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n is the number of elements in itr.\n\nIf itr is an AbstractArray, dims can be provided to compute the variance over dimensions.\n\nA pre-computed mean may be provided. When dims is specified, mean must be an array with the same shape as mean(itr, dims=dims) (additional trailing singleton dimensions are allowed).\n\nnote: Note\nIf array contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the variance of non-missing values.\n\n\n\n\n\n","category":"method"},{"location":"api/#TransitionsInTimeseries.ar1_whitenoise","page":"API","title":"TransitionsInTimeseries.ar1_whitenoise","text":"ar1_whitenoise(x::AbstractVector)\n\nReturn the AR1 regression coefficient θ of a time series x by computing the analytic solution of the least-square parameter estimation under white-noise assumption for the data-generating process:\n\ntheta = sum_i=2^n x_i  x_i-1  sum_i=2^n x_i-1^2\n\n\n\n\n\n","category":"function"},{"location":"api/#Spectrum","page":"API","title":"Spectrum","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LowfreqPowerSpectrum","category":"page"},{"location":"api/#TransitionsInTimeseries.LowfreqPowerSpectrum","page":"API","title":"TransitionsInTimeseries.LowfreqPowerSpectrum","text":"LowfreqPowerSpectrum(; q_lofreq = 0.1)\n\nReturn a PrecomputableFunction containing all the necessary fields to generate a PrecomputedLowfreqPowerSpectrum. The latter can be initialized by precompute:\n\nlfps = precompute( LowfreqPowerSpectrum() )\n\nKeyword arguments:\n\nq_lofreq: a number between 0 and 1 that characterises which portion of the\n\nfrequency spectrum is considered to be low. For instance, q_lofreq = 0.1 implies  that the lowest 10% of frequencies are considered to be the low ones.\n\n\n\n\n\n","category":"type"},{"location":"api/#Nonlinear-dynamics","page":"API","title":"Nonlinear dynamics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Indicators that come from nonlinear timeseries analysis and quantify some entropy-based dynamic quantity in the timeseries. They are provided by the ComplexityMeasures.jl package, that lists 100s of possible such indicators. Here we only provide an indicator out of the box for the permutation entropy, but building something similar is trivial:","category":"page"},{"location":"api/","page":"API","title":"API","text":"function permutation_entropy(; m = 3, τ = 1)\n    est = SymbolicPermutation(; m, τ)\n    return x -> entropy_normalized(est, x)\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"permutation_entropy\nentropy","category":"page"},{"location":"api/#TransitionsInTimeseries.permutation_entropy","page":"API","title":"TransitionsInTimeseries.permutation_entropy","text":"permutation_entropy(; m = 3, τ = 1) → f\n\nReturn a function that given timeseries x it computes the normalized permutation entropy of order m with time delay τ.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsBase.entropy","page":"API","title":"StatsBase.entropy","text":"entropy(p, [b])\n\nCompute the entropy of a collection of probabilities p, optionally specifying a real number b such that the entropy is scaled by 1/log(b). Elements with probability 0 or 1 add 0 to the entropy.\n\n\n\n\n\n","category":"function"},{"location":"api/#change_metrics","page":"API","title":"Change metrics","text":"","category":"section"},{"location":"api/#Slope","page":"API","title":"Slope","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"kendalltau\nspearman\nRidgeRegressionSlope","category":"page"},{"location":"api/#TransitionsInTimeseries.kendalltau","page":"API","title":"TransitionsInTimeseries.kendalltau","text":"kendalltau(x::AbstractVector)\n\nCompute the kendall-τ correlation coefficient of the time series x. kendalltau can be used as a change metric focused on trend.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.spearman","page":"API","title":"TransitionsInTimeseries.spearman","text":"spearman(x::AbstractVector)\n\nCompute the spearman correlation coefficient of the time series x. spearman can be used as a change metric focused on trend.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.RidgeRegressionSlope","page":"API","title":"TransitionsInTimeseries.RidgeRegressionSlope","text":"RidgeRegressionSlope(; lambda = 0.0) → rr\n\nReturn a PrecomputableFunction containing all the necessary fields to generate a PrecomputedRidgeRegressionSlope. rr can be used as a change metric focused on trend.\n\nlambda is a regularization constant, usually between 0 and 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#Value-distribution-differences","page":"API","title":"Value distribution differences","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"difference_of_means","category":"page"},{"location":"api/#TransitionsInTimeseries.difference_of_means","page":"API","title":"TransitionsInTimeseries.difference_of_means","text":"difference_of_means(x::AbstractArray)\n\nReturn the absolute difference of the means of the first and second halfs of x. difference_of_means can be used as a change metric focused on value differences. Creating similar statistical differences using other moments instead of mean is trivial. In fact, the source of difference_of_means is just:\n\n# assumes 1-based indexing\nn = length(x)\nx1 = view(x, 1:n÷2)\nx2 = view(x, (n÷2 + 1):n)\nreturn abs(mean(x1) - mean(x2))\n\ndifference_of_means can also sensibly be used for windows of size 2, in which case the change metric timeseries is the same as the abs.(diff(...)) of the indicator timeseries.\n\n\n\n\n\n","category":"function"},{"location":"api/#own_indicator","page":"API","title":"Make your own indicator/metric!","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The only difference between what is an \"indicator\" and what is a \"change metric\" is purely conceptual. As far as the code base of TransitionsInTimeseries.jl is concerned, they are both functions f: x::AbstractVector{Real} -> f(x)::Real. As a user you may give any such function for an indicator or change metric.","category":"page"},{"location":"api/","page":"API","title":"API","text":"There are situations where you may optimize such a function based on knowledge of input x type and length.","category":"page"},{"location":"api/","page":"API","title":"API","text":"TODO: Here explain how to use precomputable functions","category":"page"},{"location":"api/","page":"API","title":"API","text":"PrecomputableFunction\nprecompute","category":"page"},{"location":"api/#TransitionsInTimeseries.PrecomputableFunction","page":"API","title":"TransitionsInTimeseries.PrecomputableFunction","text":"PrecomputableFunction\n\nSupertype of structs containing the necessary field to precompute a ::Function by:\n\nprecompute(f::PrecomputableFunction, t)\n\n\n\n\n\n","category":"type"},{"location":"api/#Surrogates","page":"API","title":"Surrogates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"For the surrogate generation, you can use any subtype of Surrogate defined in Timeseriessurrogates.jl.","category":"page"},{"location":"api/#Sliding-windows","page":"API","title":"Sliding windows","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"WindowViewer\nwindowmap\nwindowmap!","category":"page"},{"location":"api/#TransitionsInTimeseries.WindowViewer","page":"API","title":"TransitionsInTimeseries.WindowViewer","text":"WindowViewer(x; width, stride)\n\nInitialize an iterator that generates views over the given timeseries x based on a window with a given width, incrementing the window views with the given stride. You can use this directly with map, such as map(std, WindowViewer(x, ...)) would give you the moving-window-timeseries of the std of x.\n\nIf not given, the keywords width, stride are taken as default_window_width(x) and 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitionsInTimeseries.windowmap","page":"API","title":"TransitionsInTimeseries.windowmap","text":"windowmap(f::Function, x::AbstractVector; kwargs...) → mapped_f\n\nA shortcut for first generating a wv = WindowViewer(x; kwargs...) and then applying mapped_f = map(f, wv). If x is accompanied by a time vector t, you probably also want to call this function with t instead of x and with one of mean, midpoint, midvalue as f to obtain a time vector for the mapped_f output.\n\n\n\n\n\n","category":"function"},{"location":"api/#TransitionsInTimeseries.windowmap!","page":"API","title":"TransitionsInTimeseries.windowmap!","text":"windowmap!(f::Function, out, x::AbstractVector; kwargs...)\n\nSame as windowmap, but writes the output in-place in out.\n\n\n\n\n\n","category":"function"},{"location":"api/#Load-data","page":"API","title":"Load data","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"load_linear_vs_doublewell()","category":"page"},{"location":"api/#TransitionsInTimeseries.load_linear_vs_doublewell-Tuple{}","page":"API","title":"TransitionsInTimeseries.load_linear_vs_doublewell","text":"load_linear_vs_doublewell()\n\nLoad prototypical data from a linear and a double-well model to test some indicators.\n\n\n\n\n\n","category":"method"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"EditURL = \"do-events.jl\"","category":"page"},{"location":"examples/do-events/#Dansgaard-Oescher-events","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"","category":"section"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"The delta^18O time series of the North Greenland Ice Core Project (NGRIP) are, to this date, the best proxy record for the Dansgaard-Oeschger events (DO-events). DO-events are sudden warming episodes of the North Atlantic, reaching to 10 degrees of regional warming within 100 years. They happened quasi-periodically over the last glacial cycle due to transitions between strong and weak states of the Atlantic Meridional Overturning Circulation and might be therefore be the most prominent examples of abrupt transitions in the field of climate science. We here propose to hindcast these events by applying the theory of Critical Slowing Down (CSD) on the NGRIP data, which can be found here in its raw format. This analysis has already been done in [Boers2018] and we here try to reproduce Figure 2.d-f.","category":"page"},{"location":"examples/do-events/#Preprocessing-NGRIP","page":"Dansgaard-Oescher events","title":"Preprocessing NGRIP","text":"","category":"section"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"Over this example, it will appear that the convenience of TransitionsInTimeseries to leads the bulk of the code to be written for plotting and preprocessing. The latter consists in various steps i = lbrace 123 rbrace:","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"Load the data, reverse and offset it to have time vector = time before 2000 AD.\nFilter non-unique points in time and sort the data.\nRegrid the data from uneven to even sampling.","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"The time and delta^18O vectors resulting from step i are respectively called t_i and x_i. The final preprocessing step consists in obtaining a residual r, i.e. the fluctuations of the system around the attractor, which, within the CSD theory, is assumed to be tracked.","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"using DelimitedFiles, Downloads, DSP, BSplineKit, Loess\n\nfunction load_ngrip()\n    tmp = Base.download(\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/\"*\n        \"master/timeseries/NGRIP.csv\")\n    data, labels = readdlm(tmp, header = true)\n    return reverse(data[:, 1]) .- 2000, reverse(data[:, 2]) # (time, delta-18-0) vectors\nend\n\nuniqueidx(v) = unique(i -> v[i], eachindex(v))\nfunction keep_unique(t, x)\n    unique_idx = uniqueidx(t)\n    return t[unique_idx], x[unique_idx]\nend\n\nfunction sort_timeseries!(t, x)\n    p = sortperm(t)\n    permute!(t, p)\n    permute!(x, p)\n    return nothing\nend\n\nfunction regrid2evensampling(t, x, dt)\n    itp = BSplineKit.interpolate(t, x, BSplineOrder(4))\n    tspan = (ceil(minimum(t)), floor(maximum(t)))\n    t_even = collect(tspan[1]:dt:tspan[2])\n    x_even = itp.(t_even)\n    return t_even, x_even\nend\n\nfunction chebyshev_filter(t, x, fcutoff)\n    ii = 10     # Chebyshev filtering requires to prune first points of time series.\n    responsetype = Highpass(fcutoff, fs = 1/dt)\n    designmethod = Chebyshev1(8, 0.05)\n    r = filt(digitalfilter(responsetype, designmethod), x)\n    xtrend = x - r\n    return t[ii:end], x[ii:end], xtrend[ii:end], r[ii:end]\nend\n\ndt, fcutoff = 5.0, 0.95*0.01    # dt = 5 yr and cutoff ≃ 0.01 yr^-1 as in (Boers 2018)\nt1, x1 = load_ngrip()\nt2, x2 = keep_unique(t1, x1)\nsort_timeseries!(t2, x2)\nt3, x3 = regrid2evensampling(t2, x2, dt)\nt, x, xtrend, r = chebyshev_filter(t3, x3, fcutoff)","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"Let's now go to the last preprocessing steps and visualize our data in what will become our main figure. To keep the same approach as in [Boers2018], we hand-code the transition times and highlight them by purple vertical lines:","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"using CairoMakie\n\nfunction loess_filter(t, x; span = 0.005)\n    loessmodel = loess(t, x, span = span)\n    xtrend = Loess.predict(loessmodel, t)\n    r = x - xtrend\n    return t, x, xtrend, r\nend\n\nfunction kyr_xticks(tticks_yr)\n    tticks_kyr = [\"$t\" for t in Int.(tticks_yr ./ 1e3)]\n    return (tticks_yr, tticks_kyr)\nend\n\nfunction plot_do(traw, xraw, tfilt, xfilt, t, r, t_transitions, xlims, xticks)\n    fig = Figure(resolution = (1600, 1200), fontsize = 24)\n\n    # Original time series with transition marked by vertical lines\n    ax1 = Axis(fig[1, 1], xlabel = L\"Time (kyr) $\\,$\", ylabel = L\"$\\delta^{18}$O (permil)\",\n        xaxisposition = :top, xticks = xticks)\n    lines!(ax1, traw, xraw, color = (:gray70, 0.5))\n    lines!(ax1, tfilt, xfilt, color = :gray10, linewidth = 3)\n    vlines!(ax1, t_transitions, color = Cycled(1), linewidth = 3)\n\n    # Residual time series\n    ax2 = Axis(fig[2, 1], ylabel = L\"Residual $\\,$\", xticks = xticks,\n        xticksvisible = false, xticklabelsvisible = false)\n    lines!(ax2, t, r, color = :gray50, linewidth = 1)\n\n    # Axes for variance and AC1 time series\n    ax3 = Axis(fig[3, 1], ylabel = L\"Variance $\\,$\", xticks = xticks,\n        xticksvisible = false, xticklabelsvisible = false)\n    ax4 = Axis(fig[4, 1], xlabel = L\"Time (kyr) $\\,$\", ylabel = L\"Lag-1 autocor. $\\,$\",\n        xticks = xticks)\n\n    axs = [ax1, ax2, ax3, ax4]\n    [xlims!(ax, xlims) for ax in axs]\n    ylims!(axs[1], (-48, -34))\n    rowgap!(fig.layout, 10)\n    return fig, axs\nend\n\nxlims = (-60e3, -10e3)\nxticks = kyr_xticks(-60e3:5e3:5e3)\nt_transitions = [-59.5e3, -58.2e3, -55.8e3, -54.3e3, -49.35e3, -46.9e3, -43.45e3,\n                 -41.5e3, -40.2e3, -38.25e3, -35.5e3, -33.8e3, -32.55e3, -28.95e3,\n                 -27.85e3, -23.5e3, -14.7e3, -11.7e3]\ntloess, _, xloess, rloess = loess_filter(t3, x3)    # loess-filtered signal for visualization\n\nfig, axs = plot_do(t3, x3, tloess, xloess, t, r, t_transitions, xlims, xticks)\nfig","category":"page"},{"location":"examples/do-events/#Hindcast-on-NGRIP-data","page":"Dansgaard-Oescher events","title":"Hindcast on NGRIP data","text":"","category":"section"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"As one can see, there is not much to see so far. Residuals are impossible to simply eye-ball and we therefore use TransitionsInTimeseries to study the evolution, measured by the ridge-regression slope, of the residual's variance and lag-1 autocorrelation (AC1) over time. In many examples of the literature, including [Boers2018], the CSD analysis is performed over segments (sometimes only one) of the time series, such that a significance value is obtained for each segment. Dealing with segments can be easily done in TransitionsInTimeseries and is demonstrated here:","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"using TransitionsInTimeseries, StatsBase\nusing Random: Xoshiro\n\nac1(x) = sum(autocor(x, [1]))                   # AC1 from StatsBase\nindicators = (var, ac1)\nchange_metrics = RidgeRegressionSlope()\nopts = [(color = Cycled(2), linewidth = 3),     # plotting options\n        (color = :orange, linewidth = 3, linestyle = :dash)]\n\nfunction perform_segment_analysis(t, r, indicators, change_metrics, itime,\n    dt, n, t_transitions, margins)\n\n    # Initialize results over segment and indicator dimensions\n    pvalues = fill(Inf, length(t_transitions), length(indicators))\n    indicator_results = [fill(Inf, 3, 3) for t in t_transitions]\n\n    for i in eachindex(t_transitions)\n        # Select the correct segment limits\n        if i == 1\n            t_start = first(t)\n        else\n            t_start = t_transitions[i-1] + margins[1]\n        end\n        t_end = t_transitions[i] - margins[2]\n        i_start, i_end = argmin(abs.(t .- t_start)), argmin(abs.(t .- t_end))\n        tseg, rseg = t[i_start:i_end], r[i_start:i_end]\n        sigconfig = SurrogatesConfig(n = n, tail = :right, rng = Xoshiro(27))\n\n        if last(tseg) - first(tseg) > itime + 20.0     # only analyze if segment long enough\n            # Compute the significance of the transition metrics for the chosen segment\n            t_indicator = windowmap(last, tseg; width = Int(itime ÷ dt))\n            segconfig = WindowedIndicatorConfig(indicators, change_metrics; whichtime = last,\n                width_ind = Int(itime ÷ dt), width_cha = length(t_indicator))\n            segresults = transition_metrics(segconfig, rseg, tseg)\n            segsignif = estimate_significance(sigconfig, segresults)\n\n            # Populate the pre-allocated arrays with the results\n            pvalues[i, :] .= segsignif.pvalues[1, :]\n            indicator_results[i] = hcat(segresults.t_indicator, segresults.x_indicator)\n        end\n    end\n    return pvalues, indicator_results\nend\n\nfunction plot_segment_analysis!(axs, pvalues, t_transitions, indicator_results, margins)\n    for i in eachindex(indicator_results)   # loop over the segments\n        # Unpack indicator results\n        tind = indicator_results[i][:, 1]\n        ind = indicator_results[i][:, 2:end]\n\n        for j in axes(pvalues, 2)           # loop over the indicators\n            if !isinf(pvalues[i, j])        # only plot if enough data points for analysis\n                # Plot indicator time series and its linear regression\n                lines!(axs[j+2], tind, ind[:, j], color = Cycled(1))\n                m, p = ridgematrix(tind, 0.0) * ind[:, j]\n                if pvalues[i, j] < 0.05\n                    vlines!(axs[1], t_transitions[i] - margins[2]; opts[j]...)\n                    vlines!(axs[j+2], t_transitions[i] - margins[2]; opts[j]...)\n                    lines!(axs[j+2], tind, m .* tind .+ p, color = :gray10, linewidth = 3)\n                else\n                    lines!(axs[j+2], tind, m .* tind .+ p, color = :gray10, linewidth = 3,\n                    linestyle = :dash)\n                end\n            end\n        end\n    end\n    return nothing\nend\n\nmargins = [200, 200]        # avoid the inclusion of transition data points in the segments\npvalues, indicator_results = perform_segment_analysis(t, r,\n    indicators, change_metrics, 200.0, dt, 1_000, t_transitions, margins)\nplot_segment_analysis!(axs, pvalues, t_transitions, indicator_results, margins)\nfig","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"In [Boers2018], 13/16 and 7/16 true positives are respectively found for the variance and AC1, with 16 referring to the total number of transitions. Here we respectively find 10/16 true positives for the variance and 4/16 for AC1. The mismatch between [Boers2018] and the results shown above clearly points out that packages like TransitionsInTimeseries are wishful for research to be reproducible.","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"Given that the NGRIP data is sparse, noisy, and presents 16 transitions in total, it appears that the method generates a reasonable rate of true positives, but...","category":"page"},{"location":"examples/do-events/#Limitations-of-hindcast","page":"Dansgaard-Oescher events","title":"Limitations of hindcast","text":"","category":"section"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"Finding transition indicators by defining segments, as done above, is arguably misleading when it comes to an operational prediction task. In fact, one does not check for false positives since the analysis is always performed upto time steps shortly before the transition. To make a brief, albeit incomplete check, one can stop the analysis much before the transition and thus check whether CSD indicators would forecast a transition although there is none ahead.","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"early_margins = [200, 700]      # take \"too early\" end margin to check for false positives\nfig, axs = plot_do(t3, x3, tloess, xloess, t, r, t_transitions, xlims, xticks)\npvalues, indicator_results = perform_segment_analysis(t, r,\n    indicators, change_metrics, 200.0, dt, 1_000, t_transitions, early_margins)\nplot_segment_analysis!(axs, pvalues, t_transitions, indicator_results, early_margins)\nfig","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"From 16 predictions which should all be negative, 10 of them are positive for the variance and 3 are positive for AC1. This clearly points out that generating a reasonable amount of true positives comes here at the expense of generating many false positives. We draw attention upon the fact that checking for false positives is too seldomly performed in literature! This does not mean that the method are incorrect but rather that the NGRIP data might be too much of a challenge for a CSD analysis. This is not surprising since the delta^18O time series is noisy and sparsely re-sampled. Furthermore, interpolating over time introduces a potential bias in the statistics, even if performed on a coarse grid. Meh. Is the situation hopeless? Not completely, as we will see in the next section.","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"info: Future improvement\nSupporting the computations for uneven time series is a planned improvement of TransitionsInTimeseries. This will avoid the need of regridding data on coarse grids and will prevent from introducing any bias.","category":"page"},{"location":"examples/do-events/#Hindcasting-simulated-DO-events","page":"Dansgaard-Oescher events","title":"Hindcasting simulated DO-events","text":"","category":"section"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"In CLIMBER-X[Willeit2022], an Earth Model of Intermediate Complexity (EMIC), DO-like events can be triggered by forcing the North Atlantic with a (white noise) freshwater input. Simulated DO-like events present the big advantage of being evenly sampled in time and free of measurement noise. Unlike the segment analysis as the one performed above, the analysis fully relying on sliding windows (as introduced in the Tutorial) is a way to generate true positives while simultaneously checking for false positives, since transition metrics are computed for (almost) all time steps. We run this analysis over two exemplary simulation outputs:","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"opts = [(color = (:orange, 0.1), linewidth = 3),\n        (color = Cycled(2), linewidth = 3, linestyle = :dash)]\n\nfunction perform_sliding_analysis(t, r, indicators, change_metrics, itime, ctime,\n    istride, cstride, dt, n)\n    config = WindowedIndicatorConfig(indicators, change_metrics; whichtime = last,\n        width_ind = Int(itime ÷ dt), stride_ind = istride,\n        width_cha = Int(ctime ÷ dt), stride_cha = cstride)\n    results = transition_metrics(config, r, t)\n    sigconfig = SurrogatesConfig(n = n, tail = :right)\n    signif = estimate_significance(sigconfig, results)\n    return signif.pvalues, results\nend\n\nfunction plot_sliding_analysis!(axs, pvalues, results, threshold)\n    for j in axes(pvalues, 2)\n        vlines!(axs[1], results.t_change[pvalues[:, j] .< threshold]; opts[j]...)\n        lines!(axs[2+j], results.t_indicator, results.x_indicator[:, j], color = Cycled(1))\n        vlines!(axs[2+j], results.t_change[pvalues[:, j] .< threshold]; opts[j]...)\n    end\n    return nothing\nend\n\nt_transitions = [[1850, 2970, 3970, 5070, 5810, 7050, 8050], [3500, 4400, 5790, 7200, 8140]]\nfigvec = Figure[]\nfor i in 1:2\n    # Download the data and perform loess filtering on it\n    tmp = Base.download(\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/\" *\n        \"master/timeseries/climberx-do$(i)-omaxa.csv\")\n    data = readdlm(tmp)\n    tcx, xcx = data[1, :], data[2, :]\n    t, x, xtrend, r = loess_filter(tcx, xcx, span = 0.02)\n\n    # Initialize figure\n    xlims = (0, last(tcx))\n    xticks = kyr_xticks(xlims[1]:1e3:xlims[2])\n    fig, axs = plot_do(tcx, xcx,  t, xtrend, t, r, t_transitions[i], xlims, xticks)\n    ylims!(axs[1], (5, 40))\n    axs[1].ylabel = L\"Max. Atlantic overturning (Sv) $\\,$\"\n\n    # Run sliding analysis and update figure with results\n    dt = mean(diff(tcx))\n    pvalues, results = perform_sliding_analysis(t, r, indicators, change_metrics,\n        500.0, 20.0, 1, 1, dt, 1_000)\n    plot_sliding_analysis!(axs, pvalues, results, 0.01)\n    vlines!(axs[1], t_transitions[i], color = Cycled(1), linewidth = 3)\n    push!(figvec, fig)\nend\nfigvec[1]","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"We here notice that transitions are always preceeded (early enough but not too early) by a significant increase of AC1, sometimes accompanied by the variance. Diagnostics seem to be very reliable, since all transitions lead to both indicators showing significant increases, synchronously and/or subsequently to the transition. False positives continue to arise, however with much lower ratio than on the NGRIP data. It seems like clean data already allows much better results! To make sure we were not simply lucky, let's look at another simulation:","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"figvec[2]","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"Things look equally good here! Assuming that these simulations capture the DO dynamics well, one can hope that higher resolution data with less noise allows to robustly predict and/or diagnose DO events. We here draw attention upon the fact that even dt = 1  mathrmyr is a relatively sparse sampling for a physical, simulated process displaying transitions with a quasi-period of T in 1000 1500  mathrmyr.","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"[Boers2018]: Niklas Boers (2018): Early-warning signals for Dansgaard-Oeschger events in a high-resolution ice core record","category":"page"},{"location":"examples/do-events/","page":"Dansgaard-Oescher events","title":"Dansgaard-Oescher events","text":"[Willeit2022]: Matteo Willeit et al. (2022): The Earth system model CLIMBER-X v1.0 – Part 1: Climate model description and validation​​​​​​​​​​​​​​","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"tutorial.jl\"","category":"page"},{"location":"examples/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"examples/tutorial/#workflow","page":"Tutorial","title":"Workflow","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Computing transition indicators consists of the following steps:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Doing any preprocessing of raw data first, such as detrending (not part of TransitionsInTimeseries.jl). This yields the input timeseries.\nEstimating the timeseries of an indicator by sliding a window over the input timeseries.\nComputing the changes of the indicator by sliding a window over its timeseries.\nGenerating many surrogates that preserve important statistical properties of the original timeseries.\nPerforming step 2 and 3 for the surrogate timeseries.\nChecking whether the indicator change timeseries of the real timeseries shows a significant feature (trend, jump or anything else) when compared to the surrogate data.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"These steps are illustrated one by one in the tutorial below, and then summarized in the convenient API that TransitionsInTimeseries.jl exports.","category":"page"},{"location":"examples/tutorial/#example_stepbystep","page":"Tutorial","title":"Tutorial – Educational","text":"","category":"section"},{"location":"examples/tutorial/#Raw-input-data","page":"Tutorial","title":"Raw input data","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Let us load data from a bistable nonlinear model subject to noise and to a gradual change of the forcing that leads to a transition. Furthermore, we also load data from a linear model, which is by definition monostable and therefore incapable of transitioning. This is done to control the rate of false positives, a common problem that can emerge when looking for transition indicators. The models are governed by:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"dfracmathrmdx_lmathrmdt = - x_l - 1 + f(t) + n(t) \ndfracmathrmdx_nlmathrmdt = - x_nl^3 + x_nl + f(t) + n(t)","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"with x_l the state of the linear model, x_nl the state of the bistable model, f the forcing and n the noise. For f=0 they both display an equilibrium point at x=-1. However, the bistable model also displays a further equilibrium point at x=1. Loading (and visualizing with Makie) such prototypical data to test some indicators can be done by simply running:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"using TransitionsInTimeseries, CairoMakie\n\nt, x_linear, x_nlinear = load_linear_vs_doublewell()\nfig, ax = lines(t, x_linear)\nlines!(ax, t, x_nlinear)\nax.title = \"raw data\"\nfig","category":"page"},{"location":"examples/tutorial/#Preprocessing","page":"Tutorial","title":"Preprocessing","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Not part of TransitionsInTimeseries.jl\nAny timeseries preprocessing, such as the de-trending step we do here, is not part of TransitionsInTimeseries.jl and is the responsibility of the researcher.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"The nonlinear system clearly displays a transition between two stability regimes. To forecast such transition, we analyze the fluctuations of the timeseries around the attractor, assumed to be tracked. Therefore, a detrending step is needed - here simply obtained by building the difference of the timeseries with lag 1.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"x_l_fluct = diff(x_linear)\nx_nl_fluct = diff(x_nlinear)\ntfluct = t[2:end]\n\nfig, ax = lines(tfluct, x_l_fluct)\nlines!(ax, tfluct, x_nl_fluct .+ 0.05)\nax.title = \"input timeseries\"\nfig","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"At this point, x_l_fluct and x_nl_fluct are considered the input timeseries.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Detrending in Julia\nDetrending can be performed in many ways. A wide range of Julia packages exists to perform smoothing such as Loess.jl or DSP.jl. There the detrending step consists of subtracting the smoothed signal from the original one.","category":"page"},{"location":"examples/tutorial/#Indicator-timeseries","page":"Tutorial","title":"Indicator timeseries","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"We can then compute the values of some \"indicator\" (a Julia function that inputs a timeseries and outputs a number). An indicator should be a quantity that is likely to change if a transition occurs, or is about to occur in the timeseries. We compute indicators by applying a sliding window over the input timeseries, determined by the width and the stride with which it is applied. Here we demonstrate this computation with the AR1-regression coefficient (under white-noise assumption), implemented as ar1_whitenoise:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"indicator = ar1_whitenoise\nindicator_window = (width = 400, stride = 1)\n\n# By mapping `last::Function` over a windowviewer of the time vector,\n# we obtain the last time step of each window.\n# This therefore only uses information from `k-width+1` to `k` at time step `k`.\n# Alternatives: `first::Function`, `midpoint:::Function`.\nt_indicator = windowmap(last, tfluct; indicator_window...)\nindicator_l = windowmap(indicator, x_l_fluct; indicator_window...)\nindicator_nl = windowmap(indicator, x_nl_fluct; indicator_window...)\n\nfig, ax = lines(t_indicator, indicator_l)\nlines!(ax, t_indicator, indicator_nl)\nax.title = \"indicator timeseries\"\nfig","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"The lines plotted above are the indicator timeseries.","category":"page"},{"location":"examples/tutorial/#Change-metric-timeseries","page":"Tutorial","title":"Change metric timeseries","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"From here, we process the indicator timeseries to quantify changes in it. This step is in essence the same as before: we apply some function over a sliding window of the indicator timeseries. We call this new timeseries the change metric timeseries. In the example here, the change metric we will employ will be the slope (over a sliding window), calculated via means of a RidgeRegressionSlope:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"change_window = (width = 30, stride = 1)\nridgereg = RidgeRegressionSlope(lambda = 0.0)\nprecompridgereg = precompute(ridgereg, t[1:change_window.width])\n\nt_change = windowmap(last, t_indicator; change_window...)\nchange_l = windowmap(precompridgereg, indicator_l; change_window...)\nchange_nl = windowmap(precompridgereg, indicator_nl; change_window...)\n\nfig, ax = lines(t_change, change_l)\nlines!(ax, t_change, change_nl)\nax.title = \"change metric timeseries\"\nfig","category":"page"},{"location":"examples/tutorial/#Timeseries-surrogates","page":"Tutorial","title":"Timeseries surrogates","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected from Critical Slowing Down, an increase of the AR1-regression coefficient can be observed. Although eyeballing the timeseries might already be suggestive, we want a rigorous framework for testing for significance.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"In TransitionsIdentifiers.jl we perform significance testing using the method of timeseries surrogates and the TimeseriesSurrogates.jl Julia package. This has the added benefits of reproducibility, automation and flexibility in choosing the surrogate generation method. Note that TimeseriesSurrogates is re-exported by TransitionsInTimeseries, so that you don't have to using both of them.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"To illustrate the surrogate, we compare the change metric computed from the bistable timeseries what that computed from a surrogate of the same timeseries.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"# Generate Fourier random-phase surrogates\nusing Random: Xoshiro\ns = surrogate(x_nl_fluct, RandomFourier(), Xoshiro(123))\n\nfunction gridfig(nrows, ncols)\n    fig = Figure()\n    axs = [Axis(fig[i, j], xticklabelsvisible = i == nrows ? true : false)\n        for j in 1:ncols, i in 1:nrows]\n    rowgap!(fig.layout, 10)\n    return fig, axs\nend\nfig, axs = gridfig(2, 1)\nlines!(axs[1], tfluct, x_nl_fluct, color = Cycled(2))\nlines!(axs[1], tfluct, s .- 0.05, color = Cycled(3))\naxs[1].title = \"real signal vs. surrogate(s)\"\n\n# compute and plot indicator and change metric\nindicator_s = windowmap(indicator, s; indicator_window...)\nchange_s = windowmap(precompridgereg, indicator_s; change_window...)\n\nlines!(axs[2], t_change, change_nl, label = \"nonlin\", color = Cycled(2))\nlines!(axs[2], t_change, change_s, label = \"surrogate\", color = Cycled(3))\naxislegend()\naxs[2].title = \"change metric\"\n\n[xlims!(ax, 0, 50) for ax in axs]\nfig","category":"page"},{"location":"examples/tutorial/#Quantifying-significance","page":"Tutorial","title":"Quantifying significance","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"To quantify the significance of the values of the change metric timeseries we perform a standard surrogate test by computing the p-value w.r.t. the change metrics of thousands of surrogates of the input timeseries. A low p-value (typically p<0.05) is commonly considered as significant. To visualize significant trends, we plot the p-value vs. time:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"n_surrogates = 1_000\nfig, axs = gridfig(2, 2)\naxs[1].title = \"linear\"\naxs[2].title = \"nonlinear\"\n\nfor (j, ax, axsig, x) in zip(1:2, axs[1:2], axs[3:4], (x_l_fluct, x_nl_fluct))\n\n    orig_change = j == 1 ? change_l : change_nl\n    sgen = surrogenerator(x, RandomFourier(), Xoshiro(123))\n    pval = zeros(length(change_s))\n\n    # Collect all surrogate change metrics\n    for i in 1:n_surrogates\n        s = sgen()\n        indicator_s = windowmap(indicator, s; indicator_window...)\n        change_s = windowmap(precompridgereg, indicator_s; change_window...)\n        pval += orig_change .< change_s\n    end\n\n    pval ./= n_surrogates\n    lines!(ax, t_change, orig_change)   # ; color = Cycled(j)\n    lines!(axsig, t_change, pval)       # ; color = Cycled(j+2)\nend\n\n[xlims!(ax, 0, 50) for ax in axs]\nfig","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected, the data generated by the nonlinear model displays a significant increase of the AR1-regression coefficient before the transition, which is manifested by a low p-value. In contrast, the data generated by the linear model does not show anything similar.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Performing the step-by-step analysis of transition indicators is possible and might be preferred for users wanting high flexibility. However, this results in a substantial amount of code. We therefore provide convenience functions that wrap this analysis, as shown in the next section.","category":"page"},{"location":"examples/tutorial/#example_fastforward","page":"Tutorial","title":"Tutorial – TransitionsInTimeseries.jl","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"TransitionsInTimeseries.jl wraps this typical workflow into a simple, extendable, and modular API that researchers can use with little effort. In addition, it allows performing the same analysis for several indicators / change metrics in one go.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"The interface is simple, and directly parallelizes the Workflow. It is based on the creation of a TransitionsSurrogatesConfig, which contains a list of indicators, and corresponding metrics, to use for doing the above analysis. It also specifies what kind of surrogates to generate.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"The following blocks illustrate how the above extensive example is re-created in TransitionsInTimeseries.jl","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"using TransitionsInTimeseries, CairoMakie\n\nt, x_linear, x_nlinear = load_linear_vs_doublewell()\n\n# input timeseries and time\ninput = x_nl_fluct = diff(x_nlinear)\nt = t[2:end]\n\nfig, ax = lines(t, input)\nax.title = \"input timeseries\"\nfig","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"To perform all of the above analysis we follow a 2-step process.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Step 1, we decide what indicators and change metrics to use in WindowedIndicatorConfig and apply those via a sliding window to the input timeseries using transition_metrics.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"# These indicators are suitable for Critical Slowing Down\nindicators = (var, ar1_whitenoise)\n\n# use the ridge regression slope for both indicators\nchange_metrics = RidgeRegressionSlope()\n\n# choices go into a configuration struct\nconfig = WindowedIndicatorConfig(indicators, change_metrics;\n    width_ind = 400, width_cha = 30, whichtime = last)\n\n# choices are processed\nresults = transition_metrics(config, input, t)","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"From result we can plot the change metric timeseries:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"fig, axs = gridfig(3, 1)\nlines!(axs[1], t, input; label = \"input\", color = Cycled(2))\nscatter!(axs[2], results.t_change, results.x_change[:, 1];\n    label = \"var slopes\", color = Cycled(3))\nscatter!(axs[3], results.t_change, results.x_change[:, 2];\n    label = \"ar1 slopes\", color = Cycled(4))\n[xlims!(ax, 0, 50) for ax in axs]\nfig","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Step 2 is to estimate significance using SurrogatesConfig and the function estimate_significance!.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"sigconfig = SurrogatesConfig(n = 1000, tail = :right)\nsignif = estimate_significance(sigconfig, results)","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now plot the p-values corresponding to each time series of the change metrics. From the flags we can additionally obtain the time points where both indicators show significance, via a simple reduction:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"fig, axs = gridfig(2, 1)\nlines!(axs[1], vcat(0.0, t), x_nlinear; label = \"raw\", color = Cycled(1))\nlines!(axs[1], t, input; label = \"input\", color = Cycled(2))\nscatter!(axs[2], results.t_change, signif.pvalues[:, 1];\n    label = \"var p-values\", color = Cycled(3))\nscatter!(axs[2], results.t_change, signif.pvalues[:, 2];\n    label = \"ar1 p-values\", color = Cycled(4))\n\nflagsboth = vec(reduce(&, signif.flags; dims = 2))\nvlines!(axs[1], results.t_change[flagsboth]; label = \"flags\", color = (\"black\", 0.1))\n\n[axislegend(ax) for ax in axs]\n[xlims!(ax, 0, 50) for ax in axs]\nfig","category":"page"},{"location":"#TransitionsInTimeseries.jl","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"","category":"section"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"(Image: TransitionsInTimeseries.jl)","category":"page"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"TransitionsInTimeseries","category":"page"},{"location":"#TransitionsInTimeseries","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries","text":"TransitionsInTimeseries.jl\n\n(Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that can estimate indicators of transitions (from one dynamic regime or stable state to another) in timeseries. Also bundles the indicators with significance testing via surrogate analysis using TimeseriesSurrogates.jl. Alternative names for this package could have been: Early Warning Signals / Resilience Indicators / Regime-Shift Identifiers / Change-Point Detectors, or however else you want to call them!\n\nThis package is currently under active development and not yet registered in the Julia general registry. To install it, first go into package-manager mode in the Julia REPL (press ]) and then run\n\nadd https://github.com/JuliaDynamics/TransitionsInTimeseries.jl\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"info: Star us on GitHub!\nIf you have found this package useful, please consider starring it on GitHub. This gives us an accurate lower bound of the (satisfied) user count.","category":"page"},{"location":"#content","page":"TransitionsInTimeseries.jl","title":"Content","text":"","category":"section"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"Multi-stable systems can display abrupt transitions between two stability regimes. To predict such transitions in real-world systems solely based on data, mathematical tools have been developed in the last decades. Numerous terminologies have been used for them, such as early warning signals, resilience indicators, regime-shift identifiers, change-point detection and transition indicators. TransitionsInTimeseries.jl sticks to the latter terminology and provides an interface that:","category":"page"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"Allows a fast computation of common transition indicators with a couple of lines, as demonstrated in the example section.\nMakes the surrogate analysis to test for significance under the hub.\nCan be easily extended by any user without touching the source code.\nReduces the programming overhead for any researcher willing to benchmark new methods.\nEases the reproducibility thanks to a clear syntax, a simple installation and RNG-seeded surrogate generation.\nIncreases trustworthiness thanks to a large test suite.","category":"page"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"info: Similar projects\nAn R toolbox and a Python library already exist. However, we believe that they are difficult to extend for the user. Furthermore, they do not offer a native performant code, as here allowed by the use of Julia.","category":"page"},{"location":"#approaches","page":"TransitionsInTimeseries.jl","title":"Approaches","text":"","category":"section"},{"location":"","page":"TransitionsInTimeseries.jl","title":"TransitionsInTimeseries.jl","text":"Over the last decades, research on transition indicators has largely focused on Critical Slowing Down (CSD). CSD is observed when a system approaches a Hopf, a transcritical or a fold bifurcation and consists in a resilience loss of the system. For instance this can be diagnosed by an increase of the variance and the AR1-regression coefficient, as demonstrated in the example section. However, we emphasize that this is one out of many possible approaches for obtaining transition indicators. Recent work has explored new approaches relying on nonlinear dynamics or machine learning. TransitionsInTimeseries.jl is designed to allow these cutting-edge methods and foster the development of new ones.","category":"page"}]
}
