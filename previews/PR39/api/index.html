<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · TransitionsInTimeseries.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TransitionsInTimeseries.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">TransitionsInTimeseries.jl</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Main-analysis-functions"><span>Main analysis functions</span></a></li><li><a class="tocitem" href="#indicators"><span>Indicators</span></a></li><li><a class="tocitem" href="#change_metrics"><span>Change metrics</span></a></li><li><a class="tocitem" href="#own_indicator"><span>Make your own indicator/metric!</span></a></li><li><a class="tocitem" href="#Surrogates"><span>Surrogates</span></a></li><li><a class="tocitem" href="#Sliding-windows"><span>Sliding windows</span></a></li><li><a class="tocitem" href="#Load-data"><span>Load data</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/main/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Main-analysis-functions"><a class="docs-heading-anchor" href="#Main-analysis-functions">Main analysis functions</a><a id="Main-analysis-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Main-analysis-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.TransitionsSurrogatesConfig" href="#TransitionsInTimeseries.TransitionsSurrogatesConfig"><code>TransitionsInTimeseries.TransitionsSurrogatesConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransitionsSurrogatesConfig(indicators, change_metrics [, surrogate]; kwargs...)</code></pre><p>A configuration struct for TransitionsInTimeseries.jl that can be given to <a href="#TransitionsInTimeseries.estimate_transitions"><code>estimate_transitions</code></a>. It contains all information necessary to perform the basic <a href="@ref">Workflow</a> of the package to detect significant transitions in the input timeseries, using the method of surrogate testing to quantify significance:</p><ol><li>Estimate the timeseries of an indicator by sliding a window over the input timeseries.</li><li>Estimate changes for an indicator by sliding a window over its timeseries.</li><li>Generate many surrogates that preserve important statistical properties of the original input timeseries.</li><li>Perform steps 1 and 2 for the surrogate timeseries (and for all provided indicators).</li><li>Estimate when an indicators timeseries shows significant change (trend, jump or anything else) when compared to the surrogate timeseries when compared to the surrogate data. Significance is estimated from the p-values of the real data vs surrogate data.</li></ol><p><strong>Arguments</strong></p><ul><li><code>indicators::AbstractVector{&lt;:Function}</code> a vector of indicators. Some indicators typically used in the literature are listed in the documentation section on <a href="#indicators">indicators</a>. The analysis is performed efficiently for all indicators given.</li><li><code>change_metrics</code> change metrics corresponding to the given indicators. If given a function, the same function is used for all indicators. Otherwise, it should be a vetor of functions of the same size as <code>indicators</code>, using change metric for its corresponding indicator. Some change metrics typically used in the literature are listed in the documentation section on <a href="#change_metrics">change metrics</a>.</li><li><code>surrogate::Surrogate</code> the method to use to generate surrogates of the input timeseries. This is an optional argument that defaults to <code>RandomFourier()</code>, see <a href="#Surrogates">Surrogates</a> for alternative options.</li></ul><p>Both indicators and change metrics are generic Julia functions that input an <code>x::AbstractVector</code> and output an <code>s::Real</code>. Any appropriate function may be given and see <a href="#own_indicator">making custom indicators/change metrics</a> in the documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>width_ind::Int=100, stride_ind::Int=1</code>: width and stride given to the <a href="#TransitionsInTimeseries.WindowViewer"><code>WindowViewer</code></a> to compute the indicator from the input timeseries.</p></li><li><p><code>width_cha::Int=50, stride_cha::Int=1</code>: width and stride given to the <a href="#TransitionsInTimeseries.WindowViewer"><code>WindowViewer</code></a> to compute the change metric timeseries from the indicator timeseries.</p></li><li><p><code>whichtime = midpoint</code>: The time vector corresponding to the indicators / change metric timeseriesm is obtained from <code>t</code> using the keyword <code>whichtime</code>. Options include:</p><ul><li><code>last</code>: use the last timepoint of each window</li><li><code>midpoint</code>: use the mid timepoint of each time window</li><li><code>first</code>: use first timepoint of each window</li></ul><p>In fact, the indicators time vector is computed simply via</p><pre><code class="language-julia hljs">t_indicator = windowmap(whichtime, t; width_ind, stride_ind)
t_change = windowmap(whichtime, t_indicator; width_cha, stride_cha)</code></pre><p>so any other function of the time window may be given to extract the time point itself, such as <code>mean</code> or <code>median</code>.</p></li><li><p><code>n_surrogates::Int = 10_000</code>: how many surrogates to create.</p></li><li><p><code>rng::AbstractRNG = Random</code>.default_rng()`: a random number generator for the surrogates.</p></li><li><p><code>tail::Symbol = :both</code>: kind of tail test to do (one of <code>:left, :right, :both</code>) when estimating the p-value from the distribution of surrogate data.</p></li><li><p><code>T = Float64</code>: Element type of input timeseries to initialize some computations.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/analysis/analysis_types.jl#L9-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.estimate_transitions" href="#TransitionsInTimeseries.estimate_transitions"><code>TransitionsInTimeseries.estimate_transitions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimate_transitions([t, ] x, config::TransitionsSurrogatesConfig)</code></pre><p>Estimate possible transitions for input timeseries <code>x</code> according to the configuration. If <code>t</code> (the time vector of <code>x</code>), is not provided, it is assumed <code>t = eachindex(x)</code>.</p><p>Return the output as <a href="@ref"><code>TransitionsResults</code></a>. You can use this output also in <a href="#TransitionsInTimeseries.transition_flags"><code>transition_flags</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/analysis/perform_analysis.jl#L1-L9">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>TransitionsResults</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.transition_flags" href="#TransitionsInTimeseries.transition_flags"><code>TransitionsInTimeseries.transition_flags</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transition_flags(results::TransitionsResults, p_threshold::Real) → flags</code></pre><p>Return <code>flags::Matrix{Bool}</code>, which is an <code>n × (c+1)</code> sized matrix. Each column <code>flags[:, c]</code> is the Boolean flags that correspond to a p-value below the threshold <code>p</code> for each change metric timeseries. There are <code>c</code> change metric timeseries in total, but the <code>c+1</code>-th column of <code>flags</code> is simply the Boolean addition of all previous columns (i.e., time points where <em>all</em> indicators pass the significance).</p><p>To obtain the time windows where the <code>c</code>-th change metric is significant, simply do:</p><pre><code class="language-julia hljs">timepoints = results.t_change[flags[:, c]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/analysis/perform_analysis.jl#L117-L132">source</a></section></article><h2 id="indicators"><a class="docs-heading-anchor" href="#indicators">Indicators</a><a id="indicators-1"></a><a class="docs-heading-anchor-permalink" href="#indicators" title="Permalink"></a></h2><h3 id="Value-distribution"><a class="docs-heading-anchor" href="#Value-distribution">Value distribution</a><a id="Value-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Value-distribution" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Statistics.mean-Tuple{Any}" href="#Statistics.mean-Tuple{Any}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean(itr)</code></pre><p>Compute the mean of all elements in a collection.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>itr</code> contains <code>NaN</code> or <a href="@ref"><code>missing</code></a> values, the result is also <code>NaN</code> or <code>missing</code> (<code>missing</code> takes precedence if array contains both). Use the <a href="@ref"><code>skipmissing</code></a> function to omit <code>missing</code> entries and compute the mean of non-missing values.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Statistics

julia&gt; mean(1:20)
10.5

julia&gt; mean([1, missing, 3])
missing

julia&gt; mean(skipmissing([1, missing, 3]))
2.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.skewness" href="#StatsBase.skewness"><code>StatsBase.skewness</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">skewness(v, [wv::AbstractWeights], m=mean(v))</code></pre><p>Compute the standardized skewness of a real-valued array <code>v</code>, optionally specifying a weighting vector <code>wv</code> and a center <code>m</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.kurtosis" href="#StatsBase.kurtosis"><code>StatsBase.kurtosis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kurtosis(v, [wv::AbstractWeights], m=mean(v))</code></pre><p>Compute the excess kurtosis of a real-valued array <code>v</code>, optionally specifying a weighting vector <code>wv</code> and a center <code>m</code>.</p></div></section></article><h3 id="Critical-Slowing-Down"><a class="docs-heading-anchor" href="#Critical-Slowing-Down">Critical Slowing Down</a><a id="Critical-Slowing-Down-1"></a><a class="docs-heading-anchor-permalink" href="#Critical-Slowing-Down" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Statistics.var-Tuple{AbstractArray}" href="#Statistics.var-Tuple{AbstractArray}"><code>Statistics.var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">var(itr; corrected::Bool=true, mean=nothing[, dims])</code></pre><p>Compute the sample variance of collection <code>itr</code>.</p><p>The algorithm returns an estimator of the generative distribution&#39;s variance under the assumption that each entry of <code>itr</code> is a sample drawn from the same unknown distribution, with the samples uncorrelated. For arrays, this computation is equivalent to calculating <code>sum((itr .- mean(itr)).^2) / (length(itr) - 1)</code>. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n</code> is the number of elements in <code>itr</code>.</p><p>If <code>itr</code> is an <code>AbstractArray</code>, <code>dims</code> can be provided to compute the variance over dimensions.</p><p>A pre-computed <code>mean</code> may be provided. When <code>dims</code> is specified, <code>mean</code> must be an array with the same shape as <code>mean(itr, dims=dims)</code> (additional trailing singleton dimensions are allowed).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If array contains <code>NaN</code> or <a href="@ref"><code>missing</code></a> values, the result is also <code>NaN</code> or <code>missing</code> (<code>missing</code> takes precedence if array contains both). Use the <a href="@ref"><code>skipmissing</code></a> function to omit <code>missing</code> entries and compute the variance of non-missing values.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.ar1_whitenoise" href="#TransitionsInTimeseries.ar1_whitenoise"><code>TransitionsInTimeseries.ar1_whitenoise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ar1_whitenoise(x::AbstractVector)</code></pre><p>Return the AR1 regression coefficient <code>θ</code> of a time series <code>x</code>. Computation based on the analytic solution of the least-square parameter estimation:</p><p class="math-container">\[\theta = \sum_{i=2}^{n} x_i  x_{i-1} / \sum_{i=2}^{n} x_{i-1}^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/indicators/critical_slowing_down.jl#L4-L13">source</a></section></article><h3 id="Spectrum"><a class="docs-heading-anchor" href="#Spectrum">Spectrum</a><a id="Spectrum-1"></a><a class="docs-heading-anchor-permalink" href="#Spectrum" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.LowfreqPowerSpectrum" href="#TransitionsInTimeseries.LowfreqPowerSpectrum"><code>TransitionsInTimeseries.LowfreqPowerSpectrum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LowfreqPowerSpectrum(; q_lofreq = 0.1)</code></pre><p>Return a <a href="#TransitionsInTimeseries.PrecomputableFunction"><code>PrecomputableFunction</code></a> containing all the necessary fields to generate a <a href="#TransitionsInTimeseries.PrecomputedLowfreqPowerSpectrum"><code>PrecomputedLowfreqPowerSpectrum</code></a>. The latter can be initialized by <a href="@ref"><code>precompute</code></a>:</p><pre><code class="language-julia hljs">lfps = precompute( LowfreqPowerSpectrum() )</code></pre><p>Keyword arguments:</p><ul><li><code>q_lofreq</code>: a number between <code>0</code> and <code>1</code> that characterises which portion of the</li></ul><p>frequency spectrum is considered to be low. For instance, <code>q_lofreq = 0.1</code> implies  that the lowest 10% of frequencies are considered to be the low ones.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/indicators/spectral.jl#L2-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.PrecomputedLowfreqPowerSpectrum" href="#TransitionsInTimeseries.PrecomputedLowfreqPowerSpectrum"><code>TransitionsInTimeseries.PrecomputedLowfreqPowerSpectrum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrecomputedLowfreqPowerSpectrum(x::AbstractVector)</code></pre><p>A struct containing all the precomputed fields to efficiently perform repetitive computation of the low-frequency power spectrum (LFPS), a number between <code>0</code> and <code>1</code> that characterizes the amount of power contained in the low frequencies of the power density spectrum of <code>x</code>. Once <code>lfps::PrecomputedLowfreqPowerSpectrum</code> is initialized, it can be used as a function to obtain the LFPS of <code>x::AbstractVector</code> by:</p><pre><code class="language-julia hljs">lfps(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/indicators/spectral.jl#L35-L47">source</a></section></article><h3 id="Nonlinear-dynamics"><a class="docs-heading-anchor" href="#Nonlinear-dynamics">Nonlinear dynamics</a><a id="Nonlinear-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-dynamics" title="Permalink"></a></h3><p>Indicators that come from nonlinear timeseries analysis and quantify some entropy-based dynamic quantity in the timeseries. They are provided by the <a href="https://juliadynamics.github.io/ComplexityMeasures.jl/stable/">ComplexityMeasures.jl</a> package, that lists 100s of possible such indicators. Here we only provide an indicator out of the box for the permutation entropy, but building something similar is trivial:</p><pre><code class="language-julia hljs">function PermutationEntropy(; m = 3, τ = 1)
    est = SymbolicPermutation(; m, τ)
    return x -&gt; entropy_normalized(est, x)
end</code></pre><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.PermutationEntropy" href="#TransitionsInTimeseries.PermutationEntropy"><code>TransitionsInTimeseries.PermutationEntropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PermutationEntropy(; m = 3, τ = 1) → f</code></pre><p>Return a function that given timeseries <code>x</code> it computes the normalized permutation entropy of order <code>m</code> with time delay <code>τ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/indicators/nlts.jl#L1-L6">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>entropy</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="change_metrics"><a class="docs-heading-anchor" href="#change_metrics">Change metrics</a><a id="change_metrics-1"></a><a class="docs-heading-anchor-permalink" href="#change_metrics" title="Permalink"></a></h2><h3 id="Slope"><a class="docs-heading-anchor" href="#Slope">Slope</a><a id="Slope-1"></a><a class="docs-heading-anchor-permalink" href="#Slope" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.kendalltau" href="#TransitionsInTimeseries.kendalltau"><code>TransitionsInTimeseries.kendalltau</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kendalltau(x::AbstractVector)</code></pre><p>Compute the kendall-τ correlation coefficient of the time series <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/library/change_metrics_trend.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.spearman" href="#TransitionsInTimeseries.spearman"><code>TransitionsInTimeseries.spearman</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spearman(x::AbstractVector)</code></pre><p>Compute the spearman correlation coefficient of the time series <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/library/change_metrics_trend.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.RidgeRegressionSlope" href="#TransitionsInTimeseries.RidgeRegressionSlope"><code>TransitionsInTimeseries.RidgeRegressionSlope</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RidgeRegressionSlope(; lambda = 0.0)</code></pre><p>Return a <a href="#TransitionsInTimeseries.PrecomputableFunction"><code>PrecomputableFunction</code></a> containing all the necessary fields to generate a <a href="#TransitionsInTimeseries.PrecomputedRidgeRegressionSlope"><code>PrecomputedRidgeRegressionSlope</code></a>. The latter can be initialized by <a href="@ref"><code>precompute</code></a>:</p><pre><code class="language-julia hljs">rr = precompute(RidgeRegressionSlope(), x)</code></pre><p>Keyword arguments:</p><ul><li><code>lambda</code>: a regularization constant, usually between <code>0</code> and <code>1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/library/change_metrics_trend.jl#L20-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.PrecomputedRidgeRegressionSlope" href="#TransitionsInTimeseries.PrecomputedRidgeRegressionSlope"><code>TransitionsInTimeseries.PrecomputedRidgeRegressionSlope</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrecomputedRidgeRegressionSlope(x::AbstractVector)</code></pre><p>Return the slope of the <a href="https://en.wikipedia.org/wiki/Ridge_regression">ridge regression</a> of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/library/change_metrics_trend.jl#L48-L52">source</a></section></article><h3 id="Difference-in-value-distribution"><a class="docs-heading-anchor" href="#Difference-in-value-distribution">Difference in value distribution</a><a id="Difference-in-value-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Difference-in-value-distribution" title="Permalink"></a></h3><h2 id="own_indicator"><a class="docs-heading-anchor" href="#own_indicator">Make your own indicator/metric!</a><a id="own_indicator-1"></a><a class="docs-heading-anchor-permalink" href="#own_indicator" title="Permalink"></a></h2><p>The only difference between what is an &quot;indicator&quot; and what is a &quot;change metric&quot; is purely conceptual. As far as the code base of TransitionsInTimeseries.jl is concerned, they are both functions <code>f: x::AbstractVector{Real} -&gt; f(x)::Real</code>. As a user you may give any such function for an indicator or change metric.</p><p>There are situations where you may optimize such a function based on knowledge of input <code>x</code> type and length.</p><p>TODO: Here explain how to use precomputable functions</p><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.PrecomputableFunction" href="#TransitionsInTimeseries.PrecomputableFunction"><code>TransitionsInTimeseries.PrecomputableFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrecomputableFunction</code></pre><p>Supertype of structs containing the necessary field to precompute a <code>::Function</code> by:</p><pre><code class="language-julia hljs">precompute(f::PrecomputableFunction, t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/library/precomputation.jl#L1-L9">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>precompute</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Surrogates"><a class="docs-heading-anchor" href="#Surrogates">Surrogates</a><a id="Surrogates-1"></a><a class="docs-heading-anchor-permalink" href="#Surrogates" title="Permalink"></a></h2><p>For the surrogate generation, you can use any subtype of <code>Surrogate</code> defined in <a href="https://juliadynamics.github.io/TimeseriesSurrogates.jl/v1.0/#Surrogate-methods-1">Timeseriessurrogates.jl</a>.</p><h2 id="Sliding-windows"><a class="docs-heading-anchor" href="#Sliding-windows">Sliding windows</a><a id="Sliding-windows-1"></a><a class="docs-heading-anchor-permalink" href="#Sliding-windows" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.WindowViewer" href="#TransitionsInTimeseries.WindowViewer"><code>TransitionsInTimeseries.WindowViewer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WindowViewer(x; width, stride)</code></pre><p>Initialize an iterator that generates views over the given timeseries <code>x</code> based on a window with a given <code>width</code>, incrementing the window views with the given <code>stride</code>. You can use this directly with <code>map</code>, such as <code>map(std, WindowViewer(x, ...))</code> would give you the moving-window-timeseries of the <code>std</code> of <code>x</code>.</p><p>If not given, the keywords <code>width, stride</code> are taken as <a href="@ref"><code>default_window_width(x)</code></a> and <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/misc/windowing.jl#L8-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.windowmap" href="#TransitionsInTimeseries.windowmap"><code>TransitionsInTimeseries.windowmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">windowmap(f::Function, x::AbstractVector; kwargs...) → mapped_f</code></pre><p>A shortcut for first generating a <code>wv = WindowViewer(x; kwargs...)</code> and then applying <code>mapped_f = map(f, wv)</code>. If <code>x</code> is accompanied by a time vector <code>t</code>, you probably also want to call this function with <code>t</code> instead of <code>x</code> and with one of <code>mean, midpoint, midvalue</code> as <code>f</code> to obtain a time vector for the <code>mapped_f</code> output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/misc/windowing.jl#L45-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.windowmap!" href="#TransitionsInTimeseries.windowmap!"><code>TransitionsInTimeseries.windowmap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">windowmap!(f::Function, out, x::AbstractVector; kwargs...)</code></pre><p>Same as <a href="#TransitionsInTimeseries.windowmap"><code>windowmap</code></a>, but writes the output in-place in <code>out</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/misc/windowing.jl#L58-L62">source</a></section></article><h2 id="Load-data"><a class="docs-heading-anchor" href="#Load-data">Load data</a><a id="Load-data-1"></a><a class="docs-heading-anchor-permalink" href="#Load-data" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TransitionsInTimeseries.load_linear_vs_doublewell-Tuple{}" href="#TransitionsInTimeseries.load_linear_vs_doublewell-Tuple{}"><code>TransitionsInTimeseries.load_linear_vs_doublewell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_linear_vs_doublewell()</code></pre><p>Load prototypical data from a linear and a double-well model to test some indicators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/0b6036e3e491c5a6cf532bd95100635d107f694c/src/misc/load_data.jl#L1-L6">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 18 July 2023 08:28">Tuesday 18 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
