<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · TransitionsInTimeseries.jl</title><meta name="title" content="Tutorial · TransitionsInTimeseries.jl"/><meta property="og:title" content="Tutorial · TransitionsInTimeseries.jl"/><meta property="twitter:title" content="Tutorial · TransitionsInTimeseries.jl"/><meta name="description" content="Documentation for TransitionsInTimeseries.jl."/><meta property="og:description" content="Documentation for TransitionsInTimeseries.jl."/><meta property="twitter:description" content="Documentation for TransitionsInTimeseries.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TransitionsInTimeseries.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">TransitionsInTimeseries.jl</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#workflow"><span>Workflow</span></a></li><li><a class="tocitem" href="#example_stepbystep"><span>Tutorial – Educational</span></a></li><li><a class="tocitem" href="#example_fastforward"><span>Tutorial – TransitionsInTimeseries.jl</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/logistic/">Permutation entropy for dynamic regime changes</a></li><li><a class="tocitem" href="../examples/ks_paleojump/">Kolmogorov-Smirnov test for detecting transitions in paleoclimate timeseries</a></li><li><a class="tocitem" href="../examples/do-events/">Dansgaard-Oescher events and Critical Slowing Down</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../refs/">References</a></li><li><a class="tocitem" href="../devdocs/">Developer&#39;s documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/TransitionsInTimeseries.jl/blob/main/docs/src/tutorial.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><h2 id="workflow"><a class="docs-heading-anchor" href="#workflow">Workflow</a><a id="workflow-1"></a><a class="docs-heading-anchor-permalink" href="#workflow" title="Permalink"></a></h2><p>Computing transition indicators consists of the following steps:</p><ol><li>Doing any preprocessing of raw data first, such as detrending. <em>This not part of TransitionsInTimeseries.jl</em> and yields the <strong>input timeseries</strong>.</li><li>Estimating the timeseries of an indicator by sliding a window over the input timeseries.</li><li>Computing the changes of the indicator by sliding a window over its timeseries. Alternatively, the change metric can be estimated over the whole segment, as examplified in the section <a href="#segmented_windows">Segmented windows</a>.</li><li>Generating many surrogates that preserve important statistical properties of the original timeseries.</li><li>Performing step 2 and 3 for the surrogate timeseries.</li><li>Checking whether the indicator change timeseries of the real timeseries shows a significant feature (trend, jump or anything else) when compared to the surrogate data.</li></ol><p>These steps are illustrated one by one in the tutorial below, and then summarized in the convenient API that TransitionsInTimeseries.jl exports.</p><h2 id="example_stepbystep"><a class="docs-heading-anchor" href="#example_stepbystep">Tutorial – Educational</a><a id="example_stepbystep-1"></a><a class="docs-heading-anchor-permalink" href="#example_stepbystep" title="Permalink"></a></h2><h3 id="Raw-input-data"><a class="docs-heading-anchor" href="#Raw-input-data">Raw input data</a><a id="Raw-input-data-1"></a><a class="docs-heading-anchor-permalink" href="#Raw-input-data" title="Permalink"></a></h3><p>Let us load data from a bistable nonlinear model subject to noise and to a gradual change of the forcing that leads to a transition. Furthermore, we also load data from a linear model, which is by definition monostable and therefore incapable of transitioning. This is done to control the rate of false positives, a common problem that can emerge when looking for transition indicators. The models are governed by:</p><p class="math-container">\[\dfrac{\mathrm{d}x_{l}}{\mathrm{d}t} = - x_{l} - 1 + f(t) + n(t) \\
\dfrac{\mathrm{d}x_{nl}}{\mathrm{d}t} = - x_{nl}^3 + x_{nl} + f(t) + n(t)\]</p><p>with <span>$x_{l}$</span> the state of the linear model, <span>$x_{nl}$</span> the state of the bistable model, <span>$f$</span> the forcing and <span>$n$</span> the noise. For <span>$f=0$</span> they both display an equilibrium point at <span>$x=-1$</span>. However, the bistable model also displays a further equilibrium point at <span>$x=1$</span>. Loading (and visualizing with <a href="https://docs.makie.org/stable/">Makie</a>) such prototypical data to test some indicators can be done by simply running:</p><pre><code class="language-julia hljs">using TransitionsInTimeseries, CairoMakie

t, x_linear, x_nlinear = load_linear_vs_doublewell()
fig, ax = lines(t, x_linear)
lines!(ax, t, x_nlinear)
ax.title = &quot;raw data&quot;
fig</code></pre><img src="5a8e0316.png" alt="Example block output"/><h3 id="Preprocessing"><a class="docs-heading-anchor" href="#Preprocessing">Preprocessing</a><a id="Preprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Preprocessing" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Not part of TransitionsInTimeseries.jl</header><div class="admonition-body"><p>Any timeseries preprocessing, such as the de-trending step we do here, is not part of TransitionsInTimeseries.jl and is the responsibility of the researcher.</p></div></div><p>The nonlinear system clearly displays a transition between two stability regimes. To forecast such transition, we analyze the fluctuations of the timeseries around the attractor, assumed to be tracked. Therefore, a detrending step is needed - here simply obtained by building the difference of the timeseries with lag 1.</p><pre><code class="language-julia hljs">x_l_fluct = diff(x_linear)
x_nl_fluct = diff(x_nlinear)
tfluct = t[2:end]

fig, ax = lines(tfluct, x_l_fluct)
lines!(ax, tfluct, x_nl_fluct .+ 0.05)
ax.title = &quot;input timeseries&quot;
fig</code></pre><img src="69fcdca8.png" alt="Example block output"/><p>At this point, <code>x_l_fluct</code> and <code>x_nl_fluct</code> are considered the <strong>input timeseries</strong>.</p><div class="admonition is-info"><header class="admonition-header">Detrending in Julia</header><div class="admonition-body"><p>Detrending can be performed in many ways. A wide range of Julia packages exists to perform smoothing such as <a href="https://github.com/JuliaStats/Loess.jl">Loess.jl</a> or <a href="https://docs.juliadsp.org/latest/contents/">DSP.jl</a>. There the detrending step consists of subtracting the smoothed signal from the original one.</p></div></div><h3 id="Indicator-timeseries"><a class="docs-heading-anchor" href="#Indicator-timeseries">Indicator timeseries</a><a id="Indicator-timeseries-1"></a><a class="docs-heading-anchor-permalink" href="#Indicator-timeseries" title="Permalink"></a></h3><p>We can then compute the values of some &quot;indicator&quot; (a Julia function that inputs a timeseries and outputs a number). An indicator should be a quantity that is likely to change if a transition occurs, or is about to occur in the timeseries. We compute indicators by applying a sliding window over the <strong>input timeseries</strong>, determined by the width and the stride with which it is applied. Here we demonstrate this computation with the AR1-regression coefficient (under white-noise assumption), implemented as <a href="../api/#TransitionsInTimeseries.ar1_whitenoise"><code>ar1_whitenoise</code></a>:</p><pre><code class="language-julia hljs">indicator = ar1_whitenoise
indicator_window = (width = 400, stride = 1)

# By mapping `last::Function` over a windowviewer of the time vector,
# we obtain the last time step of each window.
# This therefore only uses information from `k-width+1` to `k` at time step `k`.
# Alternatives: `first::Function`, `midpoint:::Function`.
t_indicator = windowmap(last, tfluct; indicator_window...)
indicator_l = windowmap(indicator, x_l_fluct; indicator_window...)
indicator_nl = windowmap(indicator, x_nl_fluct; indicator_window...)

fig, ax = lines(t_indicator, indicator_l)
lines!(ax, t_indicator, indicator_nl)
ax.title = &quot;indicator timeseries&quot;
fig</code></pre><img src="38535bda.png" alt="Example block output"/><p>The lines plotted above are the <strong>indicator timeseries</strong>.</p><h3 id="Change-metric-timeseries"><a class="docs-heading-anchor" href="#Change-metric-timeseries">Change metric timeseries</a><a id="Change-metric-timeseries-1"></a><a class="docs-heading-anchor-permalink" href="#Change-metric-timeseries" title="Permalink"></a></h3><p>From here, we process the <strong>indicator timeseries</strong> to quantify changes in it. This step is in essence the same as before: we apply some function over a sliding window of the indicator timeseries. We call this new timeseries the <strong>change metric timeseries</strong>. In the example here, the change metric we will employ will be the slope (over a sliding window), calculated via means of a <a href="../api/#TransitionsInTimeseries.RidgeRegressionSlope"><code>RidgeRegressionSlope</code></a>:</p><pre><code class="language-julia hljs">change_window = (width = 30, stride = 1)
ridgereg = RidgeRegressionSlope(lambda = 0.0)
precompridgereg = precompute(ridgereg, t[1:change_window.width])

t_change = windowmap(last, t_indicator; change_window...)
change_l = windowmap(precompridgereg, indicator_l; change_window...)
change_nl = windowmap(precompridgereg, indicator_nl; change_window...)

fig, ax = lines(t_change, change_l)
lines!(ax, t_change, change_nl)
ax.title = &quot;change metric timeseries&quot;
fig</code></pre><img src="131c9031.png" alt="Example block output"/><h3 id="Timeseries-surrogates"><a class="docs-heading-anchor" href="#Timeseries-surrogates">Timeseries surrogates</a><a id="Timeseries-surrogates-1"></a><a class="docs-heading-anchor-permalink" href="#Timeseries-surrogates" title="Permalink"></a></h3><p>As expected from <a href="../#approaches">Critical Slowing Down</a>, an increase of the AR1-regression coefficient can be observed. Although eyeballing the timeseries might already be suggestive, we want a rigorous framework for testing for significance.</p><p>In TransitionsIdentifiers.jl we perform significance testing using the method of timeseries surrogates and the <a href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl">TimeseriesSurrogates.jl</a> Julia package. This has the added benefits of reproducibility, automation and flexibility in choosing the surrogate generation method. Note that <code>TimeseriesSurrogates</code> is re-exported by <code>TransitionsInTimeseries</code>, so that you don&#39;t have to <code>using</code> both of them.</p><p>To illustrate the surrogate, we compare the change metric computed from the bistable timeseries what that computed from a surrogate of the same timeseries.</p><pre><code class="language-julia hljs"># Generate Fourier random-phase surrogates
using Random: Xoshiro
s = surrogate(x_nl_fluct, RandomFourier(), Xoshiro(123))

function gridfig(nrows, ncols)
    fig = Figure()
    axs = [Axis(fig[i, j], xticklabelsvisible = i == nrows ? true : false)
        for j in 1:ncols, i in 1:nrows]
    rowgap!(fig.layout, 10)
    return fig, axs
end
fig, axs = gridfig(2, 1)
lines!(axs[1], tfluct, x_nl_fluct, color = Cycled(2))
lines!(axs[1], tfluct, s .- 0.05, color = Cycled(3))
axs[1].title = &quot;real signal vs. surrogate(s)&quot;

# compute and plot indicator and change metric
indicator_s = windowmap(indicator, s; indicator_window...)
change_s = windowmap(precompridgereg, indicator_s; change_window...)

lines!(axs[2], t_change, change_nl, label = &quot;nonlin&quot;, color = Cycled(2))
lines!(axs[2], t_change, change_s, label = &quot;surrogate&quot;, color = Cycled(3))
axislegend()
axs[2].title = &quot;change metric&quot;

[xlims!(ax, 0, 50) for ax in axs]
fig</code></pre><img src="17977f2d.png" alt="Example block output"/><h3 id="Quantifying-significance"><a class="docs-heading-anchor" href="#Quantifying-significance">Quantifying significance</a><a id="Quantifying-significance-1"></a><a class="docs-heading-anchor-permalink" href="#Quantifying-significance" title="Permalink"></a></h3><p>To quantify the significance of the values of the <strong>change metric timeseries</strong> we perform a standard surrogate test by computing the <a href="https://en.wikipedia.org/wiki/P-value">p-value</a> w.r.t. the change metrics of thousands of surrogates of the input timeseries. A low p-value (typically <code>p&lt;0.05</code>) is commonly considered as significant. To visualize significant trends, we plot the p-value vs. time:</p><pre><code class="language-julia hljs">n_surrogates = 1_000
fig, axs = gridfig(2, 2)
axs[1].title = &quot;linear&quot;
axs[2].title = &quot;nonlinear&quot;

for (j, ax, axsig, x) in zip(1:2, axs[1:2], axs[3:4], (x_l_fluct, x_nl_fluct))

    orig_change = j == 1 ? change_l : change_nl
    sgen = surrogenerator(x, RandomFourier(), Xoshiro(123))
    pval = zeros(length(change_s))

    # Collect all surrogate change metrics
    for i in 1:n_surrogates
        s = sgen()
        indicator_s = windowmap(indicator, s; indicator_window...)
        change_s = windowmap(precompridgereg, indicator_s; change_window...)
        pval += orig_change .&lt; change_s
    end

    pval ./= n_surrogates
    lines!(ax, t_change, orig_change)   # ; color = Cycled(j)
    lines!(axsig, t_change, pval)       # ; color = Cycled(j+2)
end

[xlims!(ax, 0, 50) for ax in axs]
fig</code></pre><img src="973fee1f.png" alt="Example block output"/><p>As expected, the data generated by the nonlinear model displays a significant increase of the AR1-regression coefficient before the transition, which is manifested by a low p-value. In contrast, the data generated by the linear model does not show anything similar.</p><p>Performing the step-by-step analysis of transition indicators is possible and might be preferred for users wanting high flexibility. However, this results in a substantial amount of code. We therefore provide convenience functions that wrap this analysis, as shown in the next section.</p><h2 id="example_fastforward"><a class="docs-heading-anchor" href="#example_fastforward">Tutorial – TransitionsInTimeseries.jl</a><a id="example_fastforward-1"></a><a class="docs-heading-anchor-permalink" href="#example_fastforward" title="Permalink"></a></h2><p>TransitionsInTimeseries.jl wraps this typical workflow into a simple, extendable, and modular API that researchers can use with little effort. In addition, it allows performing the same analysis for several indicators / change metrics in one go.</p><p>The interface is simple, and directly parallelizes the <a href="#workflow">Workflow</a>. It is based on the creation of a <a href="../api/#TransitionsInTimeseries.ChangesConfig"><code>ChangesConfig</code></a>, which contains a list of indicators, and corresponding metrics, to use for doing the above analysis. It also specifies what kind of surrogates to generate.</p><h3 id="Sliding-windows"><a class="docs-heading-anchor" href="#Sliding-windows">Sliding windows</a><a id="Sliding-windows-1"></a><a class="docs-heading-anchor-permalink" href="#Sliding-windows" title="Permalink"></a></h3><p>The following blocks illustrate how the above extensive example is re-created in TransitionsInTimeseries.jl</p><pre><code class="language-julia hljs">using TransitionsInTimeseries, CairoMakie

t, x_linear, x_nlinear = load_linear_vs_doublewell()

# input timeseries and time
input = x_nl_fluct = diff(x_nlinear)
t = t[2:end]

fig, ax = lines(t, input)
ax.title = &quot;input timeseries&quot;
fig</code></pre><img src="315b650f.png" alt="Example block output"/><p>To perform all of the above analysis we follow a 2-step process.</p><p>Step 1, we decide what indicators and change metrics to use in <a href="../api/#TransitionsInTimeseries.SlidingWindowConfig"><code>SlidingWindowConfig</code></a> and apply those via a sliding window to the input timeseries using <a href="../api/#TransitionsInTimeseries.estimate_changes"><code>estimate_changes</code></a>.</p><pre><code class="language-julia hljs"># These indicators are suitable for Critical Slowing Down
indicators = (var, ar1_whitenoise)

# use the ridge regression slope for both indicators
change_metrics = (RidgeRegressionSlope(), RidgeRegressionSlope())

# choices go into a configuration struct
config = SlidingWindowConfig(indicators, change_metrics;
    width_ind = 400, width_cha = 30, whichtime = last)

# choices are processed
results = estimate_changes(config, input, t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SlidingWindowResults
 input timeseries:              2500-element Vector{Float64}
 indicators:                    [:var, :ar1_whitenoise]
 indicator (window, stride):    (400, 1)
 change metrics:                [:PrecomputedRidgeRegressionSlope, :PrecomputedRidgeRegressionSlope]
 change metric (window, stride): (30, 1)
</code></pre><p>We can conveniently plot the information contained in <code>results</code> by using <code>plot_indicator_changes</code>:</p><pre><code class="language-julia hljs">fig = plot_indicator_changes(results)</code></pre><img src="a162dbdc.png" alt="Example block output"/><p>Step 2 is to estimate significance using <a href="../api/#TransitionsInTimeseries.SurrogatesSignificance"><code>SurrogatesSignificance</code></a> and the function <a href="../api/#TransitionsInTimeseries.significant_transitions"><code>significant_transitions</code></a>. Finally, we can conveniently plot the results obtained by updating the figure obtained above with <code>plot_significance!</code>:</p><pre><code class="language-julia hljs">signif = SurrogatesSignificance(n = 1000, tail = [:right, :right])
flags = significant_transitions(results, signif)
plot_significance!(fig, results, signif, flags = flags)
fig</code></pre><img src="f1105200.png" alt="Example block output"/><h3 id="segmented_windows"><a class="docs-heading-anchor" href="#segmented_windows">Segmented windows</a><a id="segmented_windows-1"></a><a class="docs-heading-anchor-permalink" href="#segmented_windows" title="Permalink"></a></h3><p>The analysis shown so far relies on sliding windows of the change metric. This is particularly convenient for transition detection tasks. Segmented windows for the change metric computation are however preferable when it comes to prediction tasks. By only slightly modifying the syntax used so far, one can perform the same computations on segmented windows, as well as visualise the results conveniently:</p><pre><code class="language-julia hljs">config = SegmentedWindowConfig(indicators, change_metrics,
    t[1:1], t[1200:1200]; whichtime = last, width_ind = 200,
    min_width_cha = 100)
results = estimate_changes(config, input, t)
signif = SurrogatesSignificance(n = 1000, tail = [:right, :right])
flags = significant_transitions(results, signif)
fig = plot_changes_significance(results, signif)</code></pre><img src="3e233281.png" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« TransitionsInTimeseries.jl</a><a class="docs-footer-nextpage" href="../examples/logistic/">Permutation entropy for dynamic regime changes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 13 March 2024 15:45">Wednesday 13 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
